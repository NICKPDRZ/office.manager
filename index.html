<!DOCTYPE html>
<html lang="es" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Manager: Seriales & Search</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: { bg: '#0f172a', surface: '#1e293b', border: '#334155', text: '#f8fafc', textMuted: '#94a3b8' }
                    }
                }
            }
        }
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Segoe UI', system-ui, sans-serif; transition: background-color 0.3s, color 0.3s; }
        .bg-grid { background-image: radial-gradient(#cbd5e1 1px, transparent 1px); background-size: 20px 20px; }
        .dark .bg-grid { background-image: radial-gradient(#334155 1px, transparent 1px); }
        .tool-btn { transition: all 0.2s; cursor: grab; user-select: none; }
        .tool-btn:active { cursor: grabbing; transform: scale(0.98); }
        .tool-active { background-color: #eff6ff; border-color: #3b82f6; color: #1d4ed8; }
        .dark .tool-active { background-color: #1e3a8a; border-color: #3b82f6; color: #93c5fd; }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #2563eb; cursor: pointer; margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #bfdbfe; border-radius: 2px; }
        .dark input[type=range]::-webkit-slider-thumb { background: #60a5fa; }
        .dark input[type=range]::-webkit-slider-runnable-track { background: #475569; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-dark-bg text-gray-800 dark:text-dark-text h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white dark:bg-dark-surface shadow-md z-20 p-3 flex justify-between items-center relative border-b dark:border-dark-border">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 text-white p-2 rounded-lg shadow-lg">
                <i class="fa-solid fa-server"></i>
            </div>
            <div>
                <h1 class="font-bold text-lg leading-tight hidden sm:block">Office Manager</h1>
                <p class="text-xs text-gray-500 dark:text-dark-textMuted hidden sm:block">v8.1 Seriales</p>
            </div>
        </div>

        <!-- Search Bar -->
        <div class="absolute left-1/2 transform -translate-x-1/2 w-1/3 min-w-[250px]">
            <div class="relative group">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fa-solid fa-magnifying-glass text-gray-400 group-focus-within:text-blue-500 transition-colors"></i>
                </div>
                <input type="text" id="searchInput" 
                    class="block w-full pl-10 pr-4 py-2 border-2 border-gray-100 dark:border-gray-700 rounded-full leading-5 bg-gray-50 dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-400 focus:outline-none focus:bg-white dark:focus:bg-gray-700 focus:border-blue-500 transition-all shadow-sm text-sm" 
                    placeholder="Buscar puesto (ej: D-12)..." autocomplete="off">
                <div id="searchResults" class="hidden absolute top-full left-0 w-full bg-white dark:bg-dark-surface mt-2 rounded-xl shadow-xl border border-gray-100 dark:border-dark-border overflow-hidden z-50 max-h-60 overflow-y-auto"></div>
            </div>
        </div>

        <div class="flex gap-2 items-center">
            <button onclick="toggleDarkMode()" class="w-9 h-9 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-yellow-400 flex items-center justify-center hover:bg-gray-300 transition" title="Modo Oscuro">
                <i class="fa-solid fa-moon dark:hidden"></i><i class="fa-solid fa-sun hidden dark:block"></i>
            </button>

            <input type="file" id="uploadInput" accept="image/*" class="hidden">
            <input type="file" id="loadProjectInput" accept=".json" class="hidden">

            <div class="flex bg-gray-100 dark:bg-gray-800 rounded-lg p-1 mr-2 border border-gray-200 dark:border-gray-600 hidden md:flex">
                <button onclick="document.getElementById('loadProjectInput').click()" class="px-3 py-1.5 rounded text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-white dark:hover:bg-gray-700 hover:shadow-sm transition flex items-center gap-2">
                    <i class="fa-solid fa-folder-open text-yellow-600"></i>
                </button>
                <div class="w-px bg-gray-300 dark:bg-gray-600 mx-1"></div>
                <button onclick="saveProject()" class="px-3 py-1.5 rounded text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-white dark:hover:bg-gray-700 hover:shadow-sm transition flex items-center gap-2">
                    <i class="fa-solid fa-floppy-disk text-blue-600"></i>
                </button>
            </div>

            <!-- Mobile buttons fallback -->
            <button onclick="saveProject()" class="md:hidden bg-blue-100 text-blue-600 px-3 py-2 rounded-lg"><i class="fa-solid fa-floppy-disk"></i></button>

            <button onclick="exportToExcel()" class="bg-green-600 text-white px-3 py-2 rounded-lg font-medium hover:bg-green-700 transition shadow-sm text-sm flex items-center gap-2">
                <i class="fa-solid fa-file-csv"></i> <span class="hidden sm:inline">Excel</span>
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        <!-- Sidebar -->
        <aside class="w-72 bg-white dark:bg-dark-surface border-r border-gray-200 dark:border-dark-border flex flex-col shadow-lg z-10 overflow-y-auto" id="sidebar">
            <div class="p-4 border-b border-gray-100 dark:border-dark-border bg-gray-50 dark:bg-gray-800/50">
                <h3 class="font-bold text-gray-800 dark:text-gray-200 text-sm mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-map-pin text-red-500"></i> Puestos de Red
                </h3>
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <button id="addPointBtn" onclick="toggleAddPointMode()" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-200 py-2 px-1 rounded text-xs font-bold hover:text-blue-600 hover:border-blue-300 transition flex flex-col items-center gap-1">
                        <i class="fa-solid fa-plus-circle text-lg"></i> Crear Puesto
                    </button>
                    <button id="toggleNetworkBtn" onclick="toggleNetworkMode()" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-200 py-2 px-1 rounded text-xs font-bold hover:text-blue-600 hover:border-blue-300 transition flex flex-col items-center gap-1">
                        <i class="fa-solid fa-up-down-left-right text-lg"></i> Mover
                    </button>
                </div>
                <p class="text-[10px] text-gray-400 text-center" id="modeStatus">Modo: Navegación</p>
            </div>

            <!-- Items Draggable -->
            <div class="p-4 space-y-3 flex-1">
                <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-2">Hardware</h3>
                
                <div draggable="true" ondragstart="handleDragStart(event, 'desk')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-orange-100 dark:border-orange-900/30 hover:border-orange-400 p-3 rounded-xl flex items-center gap-3">
                    <div class="w-8 h-8 bg-orange-100 dark:bg-orange-900/50 rounded flex items-center justify-center text-orange-600"><i class="fa-solid fa-table"></i></div>
                    <div><div class="font-bold text-sm dark:text-gray-200">Escritorio</div><div class="text-[10px] text-gray-400">Mueble</div></div>
                </div>

                <div class="h-px bg-gray-100 dark:bg-gray-700 my-2"></div>

                <!-- Doble Monitor -->
                <div draggable="true" ondragstart="handleDragStart(event, 'monitor')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-blue-500 p-3 rounded-xl flex items-center gap-3">
                    <div class="w-8 h-8 bg-blue-50 dark:bg-gray-700 rounded flex items-center justify-center text-blue-600"><i class="fa-solid fa-desktop"></i></div>
                    <div><div class="font-bold text-sm dark:text-gray-200">Doble Monitor</div><div class="text-[10px] text-gray-400">Kit Dual</div></div>
                </div>

                <!-- Monitor Simple (AGREGADO NUEVAMENTE) -->
                <div draggable="true" ondragstart="handleDragStart(event, 'monitor-single')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-blue-400 p-3 rounded-xl flex items-center gap-3">
                    <div class="w-8 h-8 bg-blue-50 dark:bg-gray-700 rounded flex items-center justify-center text-blue-500"><i class="fa-solid fa-tv"></i></div>
                    <div><div class="font-bold text-sm dark:text-gray-200">Monitor Simple</div><div class="text-[10px] text-gray-400">1 Pantalla</div></div>
                </div>

                <!-- Docking Station -->
                <div draggable="true" ondragstart="handleDragStart(event, 'dock')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-indigo-500 p-3 rounded-xl flex items-center gap-3">
                    <div class="w-8 h-8 bg-indigo-50 dark:bg-gray-700 rounded flex items-center justify-center text-indigo-500"><i class="fa-solid fa-plug"></i></div>
                    <div><div class="font-bold text-sm dark:text-gray-200">Dock Station</div><div class="text-[10px] text-gray-400">USB-C</div></div>
                </div>

                <!-- Controls -->
                <div id="selectionControls" class="opacity-50 pointer-events-none transition-all duration-200 bg-gray-50 dark:bg-gray-800 p-4 rounded-xl border border-gray-200 dark:border-gray-700 mt-4">
                    <p class="text-xs font-bold text-gray-500 mb-2 uppercase">Propiedades</p>
                    <div id="assignmentInfo" class="mb-2 text-xs text-blue-600 dark:text-blue-400 hidden font-bold"><i class="fa-solid fa-link"></i> <span id="assignmentText"></span></div>
                    
                    <!-- Serial Number Input -->
                    <div id="serialControl" class="mb-3 hidden">
                        <label class="block text-xs text-gray-500 mb-1 font-bold">Número de Serie (S/N)</label>
                        <input type="text" id="serialInput" class="w-full text-sm border border-gray-300 dark:border-gray-600 rounded p-1.5 bg-white dark:bg-gray-700 dark:text-white focus:border-blue-500 outline-none" placeholder="Ej: CN-0X123...">
                    </div>

                    <div class="mb-3">
                        <label class="flex justify-between text-xs text-gray-500 mb-1"><span>Tamaño</span><span id="sizeValueDisplay">100%</span></label>
                        <input type="range" id="sizeSlider" min="10" max="200" value="30" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="mb-4">
                        <label class="flex justify-between text-xs text-gray-500 mb-1"><span>Rotación</span><span id="rotationValueDisplay">0°</span></label>
                        <input type="range" id="rotationSlider" min="0" max="360" value="0" class="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="duplicateSelected()" class="bg-white dark:bg-gray-700 text-blue-600 dark:text-blue-400 border border-blue-200 dark:border-gray-600 hover:bg-blue-50 p-2 rounded text-xs font-bold">Duplicar (D)</button>
                        <button onclick="deleteSelected()" class="bg-white dark:bg-gray-700 text-red-600 dark:text-red-400 border border-red-200 dark:border-red-900 hover:bg-red-50 p-2 rounded text-xs font-bold">Borrar (Del)</button>
                    </div>
                </div>
            </div>

            <!-- Footer Stats -->
            <div class="mt-auto bg-slate-800 dark:bg-slate-900 text-white p-3 text-center text-xs">
                <div class="grid grid-cols-4 gap-1">
                    <div><div class="font-bold text-blue-400" id="count-monitor">0</div><div class="text-[9px] opacity-60">Dual</div></div>
                    <div><div class="font-bold text-blue-300" id="count-monitor-single">0</div><div class="text-[9px] opacity-60">Simp</div></div>
                    <div><div class="font-bold text-indigo-400" id="count-dock">0</div><div class="text-[9px] opacity-60">Dock</div></div>
                    <div><div class="font-bold text-orange-400" id="count-desk">0</div><div class="text-[9px] opacity-60">Mesa</div></div>
                </div>
                <button onclick="resetView()" class="mt-2 text-[10px] text-slate-400 hover:text-white flex items-center justify-center gap-1 w-full"><i class="fa-solid fa-compress"></i> Reset Vista</button>
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="flex-1 bg-gray-200 dark:bg-gray-900 relative overflow-hidden cursor-grab active:cursor-grabbing bg-grid" id="canvasContainer">
            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 pointer-events-none z-0">
                <i class="fa-regular fa-map text-6xl mb-4 opacity-30"></i>
                <h2 class="text-2xl font-bold opacity-50">Sube un Plano o Carga Proyecto</h2>
                <div class="flex gap-4 mt-6 pointer-events-auto">
                    <button onclick="document.getElementById('uploadInput').click()" class="bg-blue-600 text-white px-5 py-2 rounded-full font-bold hover:bg-blue-700 shadow-lg transition transform hover:scale-105">Nuevo Plano</button>
                    <button onclick="document.getElementById('loadProjectInput').click()" class="bg-white dark:bg-gray-700 text-gray-700 dark:text-white px-5 py-2 rounded-full font-bold shadow-lg transition transform hover:scale-105">Cargar JSON</button>
                </div>
            </div>
            <canvas id="designCanvas" class="absolute top-0 left-0 hidden shadow-2xl transition-opacity duration-300" ondragover="allowDrop(event)" ondrop="handleDrop(event)"></canvas>
            
            <!-- Zoom -->
            <div class="absolute bottom-6 right-6 flex flex-col gap-2 z-10">
                <button onclick="changeZoom(0.1)" class="w-10 h-10 bg-white dark:bg-gray-800 rounded shadow text-xl font-bold hover:text-blue-600">+</button>
                <button onclick="changeZoom(-0.1)" class="w-10 h-10 bg-white dark:bg-gray-800 rounded shadow text-xl font-bold hover:text-blue-600">-</button>
            </div>
            <!-- Toast -->
            <div id="toast" class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gray-900 text-white px-4 py-2 rounded-full shadow-xl text-sm opacity-0 transition-opacity pointer-events-none z-50"><i class="fa-solid fa-check mr-2"></i> <span id="toastMsg">OK</span></div>
        </main>
    </div>

    <script>
        // --- State ---
        let networkPoints = []; 
        let items = []; 
        let selectedItemId = null;
        let selectedNetworkPointId = null; 
        let backgroundImg = null;
        let isDarkMode = false;
        
        const ASSOCIATION_DIST = 100;
        const UPSCALE_FACTOR = 2;
        let camera = { x: 0, y: 0, zoom: 1 };
        let isDraggingCanvas = false, lastMouseX = 0, lastMouseY = 0;
        let isDraggingItem = false, isNetworkMode = false, isAddingPointMode = false; 
        let foundPoint = null;

        // --- Elements ---
        const canvas = document.getElementById('designCanvas');
        const ctx = canvas.getContext('2d');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        // --- Init ---
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) toggleDarkMode();
        
        // Listeners
        document.getElementById('uploadInput').addEventListener('change', handleImageUpload);
        document.getElementById('loadProjectInput').addEventListener('change', handleProjectLoad);
        
        canvas.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove); 
        window.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', (e) => { e.preventDefault(); changeZoom(-e.deltaY * 0.001); }, { passive: false });
        
        canvas.addEventListener('touchstart', (e) => { if(e.touches.length===1) handleMouseDown(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { if(e.touches.length===1) handleMouseMove(e); }, {passive: false});
        canvas.addEventListener('touchend', handleMouseUp);
        
        // Controls Listeners
        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            if(selectedItemId) { items.find(i=>i.id===selectedItemId).width = parseInt(e.target.value); draw(); }
        });
        document.getElementById('rotationSlider').addEventListener('input', (e) => {
            if(selectedItemId) { items.find(i=>i.id===selectedItemId).rotation = parseInt(e.target.value); draw(); }
        });
        document.getElementById('serialInput').addEventListener('input', (e) => {
            if(selectedItemId) { items.find(i=>i.id===selectedItemId).serial = e.target.value; }
        });
        
        // Search Listener
        searchInput.addEventListener('input', handleSearch);

        document.addEventListener('keydown', (e) => {
            // Ignorar teclas si estamos escribiendo en el input de serial
            if (document.activeElement === document.getElementById('serialInput') || document.activeElement === searchInput) return;

            if(e.key==='Delete'||e.key==='Backspace') { if(selectedItemId) deleteSelected(); else if(selectedNetworkPointId && isNetworkMode) deleteSelectedPoint(); }
            if(e.key==='Escape') { isAddingPointMode=false; isNetworkMode=false; updateModeUI(); draw(); searchResults.classList.add('hidden'); }
            if(e.key.toLowerCase()==='d' && selectedItemId) duplicateSelected();
        });

        // --- Search Logic ---
        function handleSearch(e) {
            const query = e.target.value.toUpperCase().trim();
            searchResults.innerHTML = '';
            
            if (query.length === 0) {
                searchResults.classList.add('hidden');
                foundPoint = null;
                draw();
                return;
            }
            
            const matches = networkPoints.filter(p => p.id.toUpperCase().includes(query));
            
            if (matches.length > 0) {
                searchResults.classList.remove('hidden');
                matches.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'p-3 hover:bg-blue-50 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 flex justify-between items-center text-sm dark:text-gray-200';
                    div.innerHTML = `<span class="font-bold">${p.id}</span> <span class="text-xs text-blue-500">Ver <i class="fa-solid fa-location-arrow"></i></span>`;
                    div.onclick = () => focusOnPoint(p);
                    searchResults.appendChild(div);
                });
            } else {
                searchResults.innerHTML = '<div class="p-4 text-gray-400 text-center text-xs">No encontrado</div>';
                searchResults.classList.remove('hidden');
            }
        }

        function focusOnPoint(point) {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            foundPoint = point;
            searchResults.classList.add('hidden');
            searchInput.value = point.id;
            
            // Calculate center
            const targetZoom = 3;
            // Coordinate math to center the point
            const px = point.x * canvas.width;
            const py = point.y * canvas.height;
            
            animateCameraTo((canvas.width/2/targetZoom)-px, (canvas.height/2/targetZoom)-py, targetZoom);
        }

        function animateCameraTo(targetX, targetY, targetZoom) {
            let steps = 20;
            let dx = (targetX - camera.x) / steps;
            let dy = (targetY - camera.y) / steps;
            let dz = (targetZoom - camera.zoom) / steps;
            function step() {
                camera.x += dx; camera.y += dy; camera.zoom += dz;
                draw();
                steps--;
                if(steps > 0) requestAnimationFrame(step);
            }
            step();
        }

        // --- Core Logic ---
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                backgroundImg = new Image();
                backgroundImg.onload = () => {
                    canvas.width = backgroundImg.width * UPSCALE_FACTOR;
                    canvas.height = backgroundImg.height * UPSCALE_FACTOR;
                    canvas.classList.remove('hidden');
                    document.getElementById('emptyState').classList.add('hidden');
                    resetView();
                    showToast("Plano cargado");
                };
                backgroundImg.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleProjectLoad(e) {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if(data.imageData) {
                        backgroundImg = new Image();
                        backgroundImg.onload = () => {
                            canvas.width = backgroundImg.width * UPSCALE_FACTOR;
                            canvas.height = backgroundImg.height * UPSCALE_FACTOR;
                            canvas.classList.remove('hidden');
                            document.getElementById('emptyState').classList.add('hidden');
                            networkPoints = data.networkPoints || [];
                            items = data.items || [];
                            resetView();
                            showToast("Proyecto cargado");
                        };
                        backgroundImg.src = data.imageData;
                    }
                } catch(err) { alert("Error al leer archivo"); }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function saveProject() {
            if(!backgroundImg) return alert("No hay proyecto para guardar.");
            try {
                const data = { version: "8.1", timestamp: Date.now(), networkPoints, items, imageData: backgroundImg.src };
                const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `oficina_${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast("Proyecto guardado");
            } catch(e) { alert("Error al guardar (Archivo muy grande?)"); }
        }

        function exportToExcel() {
            if(!backgroundImg && items.length === 0) return alert("Nada para exportar.");
            
            // Build CSV Content
            let rows = [['ID Puesto', 'Escritorios', 'Kits Mon.', 'Mon. Simples', 'Docks', 'Seriales Monitores', 'Seriales Docks', 'Status']];
            
            const getSerials = (itemList, type) => {
                return itemList.filter(i => (type === 'monitor' ? (i.type === 'monitor' || i.type === 'monitor-single') : i.type === type) && i.serial)
                               .map(i => i.serial)
                               .join(" | ");
            };

            // 1. Process Puntos
            if (networkPoints.length > 0) {
                networkPoints.forEach(p => {
                    const assignedItems = items.filter(i => {
                        const nearest = getNearestPoint(i);
                        return nearest && nearest.point.id === p.id;
                    });

                    let desks = assignedItems.filter(i => i.type === 'desk').length;
                    let dual = assignedItems.filter(i => i.type === 'monitor').length;
                    let single = assignedItems.filter(i => i.type === 'monitor-single').length;
                    let docks = assignedItems.filter(i => i.type === 'dock').length;
                    
                    let serialsMon = getSerials(assignedItems, 'monitor');
                    let serialsDock = getSerials(assignedItems, 'dock');

                    rows.push([p.id, desks, dual, single, docks, serialsMon, serialsDock, 'Asignado']);
                });
            }

            // 2. Process Unassigned Items
            let unassigned = items.filter(i => !getNearestPoint(i));
            if (unassigned.length > 0) {
                let uDesks = unassigned.filter(i => i.type === 'desk').length;
                let uDual = unassigned.filter(i => i.type === 'monitor').length;
                let uSingle = unassigned.filter(i => i.type === 'monitor-single').length;
                let uDocks = unassigned.filter(i => i.type === 'dock').length;
                let uSerialsMon = getSerials(unassigned, 'monitor');
                let uSerialsDock = getSerials(unassigned, 'dock');

                rows.push(['SIN ASIGNAR', uDesks, uDual, uSingle, uDocks, uSerialsMon, uSerialsDock, 'Inventario Suelto']);
            }

            const csvContent = "data:text/csv;charset=utf-8," + rows.map(e => e.join(",")).join("\n");
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "inventario_con_seriales.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast("Excel con seriales descargado");
        }

        // --- Drawing Helpers ---
        function screenToWorld(sx, sy) {
            const r = canvas.getBoundingClientRect();
            const x = (sx - r.left) * (canvas.width/r.width);
            const y = (sy - r.top) * (canvas.height/r.height);
            return { x: (x/camera.zoom) - camera.x, y: (y/camera.zoom) - camera.y };
        }

        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(!backgroundImg) return;
            
            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(camera.x, camera.y);
            
            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
            
            items.filter(i=>i.type==='desk').forEach(i => drawItemWrapper(i));
            drawAssignments();
            drawNetworkPoints(isNetworkMode || isAddingPointMode || foundPoint ? 1 : 0.5);
            items.filter(i=>i.type!=='desk').forEach(i => drawItemWrapper(i));
            
            if (foundPoint) {
                const px = foundPoint.x * canvas.width;
                const py = foundPoint.y * canvas.height;
                ctx.beginPath(); ctx.arc(px, py, 30 * UPSCALE_FACTOR, 0, Math.PI * 2);
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4 * UPSCALE_FACTOR; ctx.stroke();
            }

            ctx.restore();
            updateUI();
        }

        function drawItemWrapper(item) {
            const isSel = item.id === selectedItemId;
            ctx.save(); ctx.translate(item.x, item.y);
            if(item.rotation) ctx.rotate(item.rotation * Math.PI/180);
            const s = UPSCALE_FACTOR;
            if(isSel) {
                ctx.strokeStyle='#2563eb'; ctx.lineWidth=3/camera.zoom; 
                ctx.strokeRect((-item.width/2*s)-5, (-item.height/2*s)-5, (item.width*s)+10, (item.height*s)+10);
            }
            ctx.scale(s, s);
            drawIcon(item.type, -item.width/2, -item.height/2, item.width, item.height);
            ctx.restore();
        }
        
        function drawItemRaw(item) { 
            ctx.save(); ctx.translate(item.x, item.y);
            if(item.rotation) ctx.rotate(item.rotation * Math.PI/180);
            ctx.scale(UPSCALE_FACTOR, UPSCALE_FACTOR);
            drawIcon(item.type, -item.width/2, -item.height/2, item.width, item.height);
            ctx.restore();
        }

        function drawIcon(type, x, y, w, h) {
            const c1 = isDarkMode ? '#334155' : '#1f2937';
            const c2 = '#3b82f6';
            if(type==='monitor') {
                ctx.fillStyle=c1; ctx.fillRect(x, y, w/2-2, h*0.7); ctx.fillRect(x+w/2+2, y, w/2-2, h*0.7);
                ctx.fillStyle='#9ca3af'; ctx.fillRect(x+w/2-2, y+h*0.7, 4, h*0.3);
            } else if(type==='monitor-single') {
                ctx.fillStyle=c1; ctx.fillRect(x, y, w, h*0.75);
                ctx.fillStyle='#9ca3af'; ctx.fillRect(x+w/2-3, y+h*0.75, 6, h*0.25);
            } else if(type==='dock') {
                ctx.fillStyle='#4f46e5'; ctx.roundRect(x, y+h*0.25, w, h*0.5, 4); ctx.fill();
            } else if(type==='desk') {
                ctx.fillStyle=isDarkMode?'#78350f':'#d4a373'; ctx.roundRect(x, y, w, h, 4); ctx.fill();
            }
        }

        function drawNetworkPoints(opacity) {
            networkPoints.forEach(p => {
                const px = p.x * canvas.width, py = p.y * canvas.height;
                const isSel = p.id === selectedNetworkPointId;
                const isFound = foundPoint && foundPoint.id === p.id;
                
                ctx.beginPath(); ctx.arc(px, py, 10*UPSCALE_FACTOR, 0, Math.PI*2);
                ctx.fillStyle = (isSel || isFound) ? '#ef4444' : `rgba(59, 130, 246, ${opacity})`; ctx.fill();
                
                if(opacity > 0.5 || isFound) {
                    ctx.fillStyle = isDarkMode ? 'rgba(15, 23, 42, 0.8)' : 'rgba(255,255,255,0.8)'; 
                    ctx.font=`bold ${12*UPSCALE_FACTOR}px Arial`;
                    const m = ctx.measureText(p.id);
                    const padding = 5;
                    ctx.fillRect(px - m.width/2 - padding, py - (35*UPSCALE_FACTOR), m.width+(padding*2), 20*UPSCALE_FACTOR);
                    ctx.fillStyle= isDarkMode ? '#fff' : '#000'; 
                    ctx.fillText(p.id, px - m.width/2, py - (20*UPSCALE_FACTOR));
                }
            });
        }

        function drawAssignments() {
            items.forEach(i => {
                if(i.type==='desk') return;
                const near = getNearestPoint(i);
                if(near) {
                    const p = near.point;
                    ctx.beginPath(); ctx.moveTo(i.x, i.y); ctx.lineTo(p.x*canvas.width, p.y*canvas.height);
                    ctx.strokeStyle='rgba(37,99,235,0.5)'; ctx.lineWidth = 3; ctx.setLineDash([10,10]); ctx.stroke(); ctx.setLineDash([]);
                }
            });
        }

        function handleMouseDown(e) {
            e.preventDefault();
            if(document.activeElement === document.getElementById('serialInput')) document.activeElement.blur();

            const r = canvas.getBoundingClientRect();
            const cx = (e.clientX - r.left) * (canvas.width/r.width);
            const cy = (e.clientY - r.top) * (canvas.height/r.height);
            const wx = (cx/camera.zoom) - camera.x;
            const wy = (cy/camera.zoom) - camera.y;

            if(isAddingPointMode) {
                const id = prompt("Nombre del puesto (ej: D-01):");
                if(id) {
                    networkPoints.push({id: id.toUpperCase(), x: wx/canvas.width, y: wy/canvas.height});
                    draw();
                }
                return;
            }
            
            if(e.button===1 || e.button===2) { isDraggingCanvas=true; lastMouseX=e.clientX; lastMouseY=e.clientY; return; }

            const s = UPSCALE_FACTOR;
            let hitItem = null;
            for(let i=items.length-1; i>=0; i--) {
                const it = items[i];
                if(wx >= it.x - it.width*s/2 && wx <= it.x + it.width*s/2 && wy >= it.y - it.height*s/2 && wy <= it.y + it.height*s/2) {
                    hitItem = it; break;
                }
            }
            
            if(hitItem) {
                selectedItemId = hitItem.id; selectedNetworkPointId = null;
                isDraggingItem = true; 
                hitItem.dragOffX = wx - hitItem.x;
                hitItem.dragOffY = wy - hitItem.y;
                updateUI();
                draw();
                return;
            }

            const hitPoint = networkPoints.find(p => Math.sqrt((wx - p.x*canvas.width)**2 + (wy - p.y*canvas.height)**2) < 20*s);
            if(hitPoint) {
                selectedNetworkPointId = hitPoint.id; selectedItemId = null;
                if(isNetworkMode) isDraggingItem = true;
                draw();
                return;
            }

            isDraggingCanvas = true; lastMouseX=e.clientX; lastMouseY=e.clientY;
            selectedItemId = null; selectedNetworkPointId = null;
            updateUI();
            draw();
        }

        function handleMouseMove(e) {
            if(isDraggingItem && selectedItemId) {
                const r = canvas.getBoundingClientRect();
                const wx = ((e.clientX - r.left) * (canvas.width/r.width) / camera.zoom) - camera.x;
                const wy = ((e.clientY - r.top) * (canvas.height/r.height) / camera.zoom) - camera.y;
                const item = items.find(i=>i.id===selectedItemId);
                if(item) { item.x = wx - (item.dragOffX||0); item.y = wy - (item.dragOffY||0); draw(); }
            } else if(isDraggingItem && selectedNetworkPointId && isNetworkMode) {
                const r = canvas.getBoundingClientRect();
                const wx = ((e.clientX - r.left) * (canvas.width/r.width) / camera.zoom) - camera.x;
                const wy = ((e.clientY - r.top) * (canvas.height/r.height) / camera.zoom) - camera.y;
                const p = networkPoints.find(i=>i.id===selectedNetworkPointId);
                if(p) { p.x = wx/canvas.width; p.y = wy/canvas.height; draw(); }
            } else if(isDraggingCanvas) {
                const dx = e.clientX - lastMouseX; const dy = e.clientY - lastMouseY;
                lastMouseX = e.clientX; lastMouseY = e.clientY;
                const scaleX = canvas.width / canvas.getBoundingClientRect().width;
                camera.x += (dx * scaleX) / camera.zoom;
                camera.y += (dy * scaleX) / camera.zoom;
                draw();
            }
        }

        function handleMouseUp() { isDraggingCanvas=false; isDraggingItem=false; }

        function handleDragStart(e, type) { e.dataTransfer.setData("type", type); }
        function allowDrop(e) { e.preventDefault(); }
        function handleDrop(e) {
            e.preventDefault();
            if(!backgroundImg) return alert("Sube un plano primero");
            const type = e.dataTransfer.getData("type");
            const r = canvas.getBoundingClientRect();
            const wx = ((e.clientX - r.left)*(canvas.width/r.width)/camera.zoom) - camera.x;
            const wy = ((e.clientY - r.top)*(canvas.height/r.height)/camera.zoom) - camera.y;
            
            const id = Date.now();
            let w=20, h=20; 
            if(type==='desk') { w=40; h=25; }
            if(type==='monitor') { w=30; h=18; }
            if(type==='monitor-single') { w=20; h=15; }
            if(type==='dock') { w=15; h=15; }

            items.push({id, type, x: wx, y: wy, width: w, height: h, rotation: 0, serial: ''});
            selectedItemId = id; 
            updateUI();
            draw();
        }

        function getNearestPoint(item) {
            if(!networkPoints.length) return null;
            let min=Infinity, close=null;
            networkPoints.forEach(p => {
                const d = Math.sqrt((item.x - p.x*canvas.width)**2 + (item.y - p.y*canvas.height)**2);
                if(d < min) { min=d; close=p; }
            });
            return min < ASSOCIATION_DIST*UPSCALE_FACTOR ? {point: close} : null;
        }

        function deleteSelected() { items = items.filter(i=>i.id!==selectedItemId); selectedItemId=null; updateUI(); draw(); }
        function duplicateSelected() { 
            const i = items.find(x=>x.id===selectedItemId);
            if(i) { 
                const nid = Date.now(); 
                items.push({...i, id: nid, x: i.x+(20*UPSCALE_FACTOR), y: i.y+(20*UPSCALE_FACTOR), serial: ''});
                selectedItemId=nid; updateUI(); draw(); 
            } 
        }
        function toggleAddPointMode() { isAddingPointMode=!isAddingPointMode; isNetworkMode=false; updateUI(); }
        function toggleNetworkMode() { isNetworkMode=!isNetworkMode; isAddingPointMode=false; updateUI(); }
        function changeZoom(d) { camera.zoom = Math.max(0.1, camera.zoom+d); draw(); }
        function resetView() { camera = {x:0, y:0, zoom:1}; draw(); }
        function toggleDarkMode() { isDarkMode=!isDarkMode; document.documentElement.classList.toggle('dark'); draw(); }
        function showToast(m) { const t=document.getElementById('toast'); document.getElementById('toastMsg').innerText=m; t.classList.remove('opacity-0'); setTimeout(()=>t.classList.add('opacity-0'),2000); }
        
        function updateUI() {
            const btnA = document.getElementById('addPointBtn');
            const btnN = document.getElementById('toggleNetworkBtn');
            btnA.className = isAddingPointMode ? btnA.className.replace('text-gray-600', 'text-green-600 bg-green-50') : btnA.className.replace('text-green-600 bg-green-50', 'text-gray-600');
            btnN.className = isNetworkMode ? btnN.className.replace('text-gray-600', 'text-blue-600 bg-blue-50') : btnN.className.replace('text-blue-600 bg-blue-50', 'text-gray-600');
            document.getElementById('modeStatus').innerText = isAddingPointMode ? "Haz CLIC para crear" : (isNetworkMode ? "ARRASTRA los puntos" : "Navegación");
            
            document.getElementById('count-monitor').innerText = items.filter(i=>i.type==='monitor').length;
            document.getElementById('count-monitor-single').innerText = items.filter(i=>i.type==='monitor-single').length;
            document.getElementById('count-dock').innerText = items.filter(i=>i.type==='dock').length;
            document.getElementById('count-desk').innerText = items.filter(i=>i.type==='desk').length;
            
            const selDiv = document.getElementById('selectionControls');
            const serialDiv = document.getElementById('serialControl');
            const serialInput = document.getElementById('serialInput');

            if(selectedItemId) {
                selDiv.classList.remove('opacity-50', 'pointer-events-none');
                const it = items.find(i=>i.id===selectedItemId);
                document.getElementById('sizeSlider').value = it.width;
                document.getElementById('rotationSlider').value = it.rotation||0;
                
                if (it.type !== 'desk') {
                    serialDiv.classList.remove('hidden');
                    serialInput.value = it.serial || '';
                } else {
                    serialDiv.classList.add('hidden');
                }

                const near = getNearestPoint(it);
                const info = document.getElementById('assignmentInfo');
                if(near && it.type!=='desk') {
                    info.classList.remove('hidden');
                    document.getElementById('assignmentText').innerText = "Conectado a: " + near.point.id;
                } else { info.classList.add('hidden'); }
            } else {
                selDiv.classList.add('opacity-50', 'pointer-events-none');
                serialInput.value = '';
            }
        }
    </script>
</body>
</html>