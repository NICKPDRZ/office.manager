<!DOCTYPE html>
<html lang="es" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Manager: Dark & Custom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f172a',
                            surface: '#1e293b',
                            border: '#334155',
                            text: '#f8fafc',
                            textMuted: '#94a3b8'
                        }
                    }
                }
            }
        }
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; transition: background-color 0.3s, color 0.3s; }
        
        /* Grid Background Pattern */
        .bg-grid {
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .dark .bg-grid {
            background-image: radial-gradient(#334155 1px, transparent 1px);
        }

        /* Tool Styles */
        .tool-btn { transition: all 0.2s; cursor: grab; }
        .tool-btn:active { cursor: grabbing; transform: scale(0.98); }
        .tool-active { background-color: #eff6ff; border-color: #3b82f6; color: #1d4ed8; }
        .dark .tool-active { background-color: #1e3a8a; border-color: #3b82f6; color: #93c5fd; }
        
        /* Slider Styling */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #2563eb; cursor: pointer; margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #bfdbfe; border-radius: 2px;
        }
        .dark input[type=range]::-webkit-slider-thumb { background: #60a5fa; }
        .dark input[type=range]::-webkit-slider-runnable-track { background: #475569; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Animations */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
        .animate-pulse-ring { animation: pulse-ring 2s infinite; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-dark-bg text-gray-800 dark:text-dark-text h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white dark:bg-dark-surface shadow-md z-20 p-3 flex justify-between items-center relative border-b dark:border-dark-border transition-colors">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 text-white p-2 rounded-lg shadow-lg shadow-blue-500/30">
                <i class="fa-solid fa-building-user"></i>
            </div>
            <div>
                <h1 class="font-bold text-lg leading-tight">Office Manager</h1>
                <p class="text-xs text-gray-500 dark:text-dark-textMuted">Diseño & Inventario</p>
            </div>
        </div>

        <!-- Search Bar -->
        <div class="absolute left-1/2 transform -translate-x-1/2 w-1/3 min-w-[300px]">
            <div class="relative group">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fa-solid fa-magnifying-glass text-gray-400 group-focus-within:text-blue-500 transition-colors"></i>
                </div>
                <input type="text" id="searchInput" 
                    class="block w-full pl-10 pr-4 py-2 border-2 border-gray-100 dark:border-gray-700 rounded-full leading-5 bg-gray-50 dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-400 focus:outline-none focus:bg-white dark:focus:bg-gray-700 focus:border-blue-500 transition-all shadow-sm" 
                    placeholder="Buscar puesto (ej: D-12)..." autocomplete="off">
                <div id="searchResults" class="hidden absolute top-full left-0 w-full bg-white dark:bg-dark-surface mt-2 rounded-xl shadow-xl border border-gray-100 dark:border-dark-border overflow-hidden z-50 max-h-60 overflow-y-auto"></div>
            </div>
        </div>

        <div class="flex gap-2 items-center">
            <!-- Dark Mode Toggle -->
            <button onclick="toggleDarkMode()" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-yellow-400 flex items-center justify-center hover:bg-gray-300 dark:hover:bg-gray-600 transition mr-2" title="Modo Oscuro/Claro">
                <i class="fa-solid fa-moon dark:hidden"></i>
                <i class="fa-solid fa-sun hidden dark:block"></i>
            </button>

            <input type="file" id="uploadInput" accept="image/*" class="hidden">
            <button onclick="document.getElementById('uploadInput').click()" class="bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 px-3 py-2 rounded-lg font-medium hover:bg-gray-50 dark:hover:bg-gray-600 transition border border-gray-200 dark:border-gray-600 text-sm shadow-sm">
                <i class="fa-solid fa-upload mr-1"></i> Plano
            </button>
            <button onclick="exportToExcel()" class="bg-green-600 text-white px-3 py-2 rounded-lg font-medium hover:bg-green-700 transition shadow-sm text-sm flex items-center gap-2">
                <i class="fa-solid fa-file-excel"></i> Excel
            </button>
            <button onclick="exportImage()" class="bg-blue-600 text-white px-3 py-2 rounded-lg font-medium hover:bg-blue-700 transition shadow-sm text-sm">
                <i class="fa-solid fa-image mr-1"></i> Imagen
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Sidebar Tools -->
        <aside class="w-72 bg-white dark:bg-dark-surface border-r border-gray-200 dark:border-dark-border flex flex-col shadow-lg z-10 overflow-y-auto transition-colors" id="sidebar">
            
            <!-- Map Controls / Add Points -->
            <div class="p-4 border-b border-gray-100 dark:border-dark-border bg-gray-50 dark:bg-gray-800/50">
                <h3 class="font-bold text-gray-800 dark:text-gray-200 text-sm mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-map-pin text-red-500"></i> Puestos de Red
                </h3>
                
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <button id="addPointBtn" onclick="toggleAddPointMode()" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-200 py-2 px-2 rounded-lg text-xs font-bold hover:bg-blue-50 dark:hover:bg-blue-900 hover:text-blue-600 hover:border-blue-300 transition flex flex-col items-center gap-1 shadow-sm">
                        <i class="fa-solid fa-plus-circle text-lg"></i> Crear Puesto
                    </button>
                    <button id="toggleNetworkBtn" onclick="toggleNetworkMode()" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-200 py-2 px-2 rounded-lg text-xs font-bold hover:bg-blue-50 dark:hover:bg-blue-900 hover:text-blue-600 hover:border-blue-300 transition flex flex-col items-center gap-1 shadow-sm">
                        <i class="fa-regular fa-eye text-lg"></i> Editar/Mover
                    </button>
                </div>
                
                <p class="text-[10px] text-gray-400 leading-tight mt-2 text-center">
                    <span id="modeStatus">Haz clic en "Crear Puesto" para empezar</span>
                </p>
            </div>

            <!-- Hardware Tools (Draggable) -->
            <div class="p-4 space-y-3 flex-1">
                <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-2">Arrastra al Mapa</h3>
                
                <!-- Desk -->
                <div draggable="true" ondragstart="handleDragStart(event, 'desk')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-orange-100 dark:border-orange-900/30 hover:border-orange-400 hover:bg-orange-50 dark:hover:bg-orange-900/50 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm mb-4 select-none">
                    <div class="w-10 h-10 bg-orange-100 dark:bg-orange-900/50 rounded-lg flex items-center justify-center text-orange-600 dark:text-orange-400">
                        <i class="fa-solid fa-table"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Escritorio</div>
                        <div class="text-[10px] text-gray-400">Mobiliario Base</div>
                    </div>
                </div>

                <div class="h-px bg-gray-100 dark:bg-gray-700 my-2"></div>

                <!-- Monitor Dual -->
                <div draggable="true" ondragstart="handleDragStart(event, 'monitor')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/30 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm select-none">
                    <div class="w-10 h-10 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-600 dark:text-gray-300 group-hover:text-blue-600">
                        <i class="fa-solid fa-desktop"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Doble Monitor</div>
                        <div class="text-[10px] text-gray-400">Kit Estándar</div>
                    </div>
                </div>

                <!-- Monitor Single -->
                <div draggable="true" ondragstart="handleDragStart(event, 'monitor-single')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/30 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm select-none">
                    <div class="w-10 h-10 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-600 dark:text-gray-300 group-hover:text-blue-500">
                        <i class="fa-solid fa-tv"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Monitor Simple</div>
                        <div class="text-[10px] text-gray-400">Kit Básico</div>
                    </div>
                </div>

                <!-- Dock -->
                <div draggable="true" ondragstart="handleDragStart(event, 'dock')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-indigo-500 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm select-none">
                    <div class="w-10 h-10 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-600 dark:text-gray-300 group-hover:text-indigo-500">
                        <i class="fa-solid fa-plug"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Docking Station</div>
                        <div class="text-[10px] text-gray-400">USB-C Hub</div>
                    </div>
                </div>

                <!-- Selection Controls -->
                <div id="selectionControls" class="opacity-50 pointer-events-none transition-all duration-200 bg-gray-50 dark:bg-gray-800 p-4 rounded-xl border border-gray-200 dark:border-gray-700 mt-4">
                    <p class="text-xs font-bold text-gray-500 dark:text-gray-400 mb-2 uppercase flex justify-between">
                        Selección Actual
                    </p>
                    
                    <div id="assignmentInfo" class="mb-3 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 p-2 rounded border border-blue-200 dark:border-blue-700 hidden">
                        <i class="fa-solid fa-link mr-1"></i> <span id="assignmentText">Sin asignar</span>
                    </div>

                    <div class="mb-4">
                        <label class="flex justify-between text-xs text-gray-600 dark:text-gray-400 mb-1 font-semibold">
                            <span>Tamaño</span>
                            <span id="sizeValueDisplay">100%</span>
                        </label>
                        <input type="range" id="sizeSlider" min="20" max="300" value="60" class="w-full h-2 bg-blue-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <button onclick="deleteSelected()" class="w-full bg-white dark:bg-gray-700 text-red-600 dark:text-red-400 border border-red-200 dark:border-red-900/50 hover:bg-red-50 dark:hover:bg-red-900/30 p-2 rounded-lg flex items-center justify-center gap-2 font-medium text-xs shadow-sm transition">
                        <i class="fa-solid fa-trash"></i> Eliminar Item
                    </button>
                </div>
            </div>

            <!-- Summary Footer -->
            <div class="mt-auto bg-slate-800 dark:bg-slate-900 text-white p-4 text-center border-t border-slate-700">
                <button onclick="resetView()" class="text-xs text-slate-400 hover:text-white mb-2 flex items-center justify-center gap-1 w-full">
                    <i class="fa-solid fa-compress-arrows-alt"></i> Centrar Mapa
                </button>
                <div class="grid grid-cols-4 gap-1">
                    <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-blue-400 text-sm" id="count-monitor">0</div>
                        <div class="text-[9px] text-slate-300">Dual</div>
                    </div>
                     <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-blue-300 text-sm" id="count-monitor-single">0</div>
                        <div class="text-[9px] text-slate-300">Simp</div>
                    </div>
                    <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-indigo-400 text-sm" id="count-dock">0</div>
                        <div class="text-[9px] text-slate-300">Dock</div>
                    </div>
                     <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-orange-400 text-sm" id="count-desk">0</div>
                        <div class="text-[9px] text-slate-300">Mesa</div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="flex-1 bg-gray-200 dark:bg-gray-900 relative overflow-hidden cursor-grab active:cursor-grabbing bg-grid" id="canvasContainer">
            
            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 pointer-events-none z-0">
                <div class="bg-white dark:bg-gray-800 p-8 rounded-full shadow-lg mb-4 animate-bounce">
                    <i class="fa-regular fa-map text-6xl text-blue-200 dark:text-blue-900"></i>
                </div>
                <h2 class="text-2xl font-bold text-gray-600 dark:text-gray-300">Bienvenido al Office Manager</h2>
                <p class="text-gray-500 dark:text-gray-500 mt-2">Sube tu plano para comenzar (La imagen será mejorada automáticamente)</p>
                <button onclick="document.getElementById('uploadInput').click()" class="mt-6 bg-blue-600 text-white px-6 py-3 rounded-xl font-bold hover:bg-blue-700 shadow-lg pointer-events-auto transition hover:scale-105 transform duration-200">
                    <i class="fa-solid fa-cloud-arrow-up mr-2"></i> Subir Plano
                </button>
            </div>

            <canvas id="designCanvas" class="absolute top-0 left-0 hidden shadow-2xl transition-opacity duration-300" ondragover="allowDrop(event)" ondrop="handleDrop(event)"></canvas>
            
            <!-- Zoom Controls -->
            <div class="absolute bottom-6 right-6 flex flex-col gap-2 z-10">
                <button onclick="changeZoom(0.1)" class="w-10 h-10 bg-white dark:bg-gray-800 rounded-lg shadow-lg text-gray-600 dark:text-gray-300 hover:text-blue-600 hover:bg-blue-50 flex items-center justify-center font-bold text-xl transition transform hover:scale-105 border border-gray-200 dark:border-gray-700">+</button>
                <button onclick="changeZoom(-0.1)" class="w-10 h-10 bg-white dark:bg-gray-800 rounded-lg shadow-lg text-gray-600 dark:text-gray-300 hover:text-blue-600 hover:bg-blue-50 flex items-center justify-center font-bold text-xl transition transform hover:scale-105 border border-gray-200 dark:border-gray-700">-</button>
            </div>

            <!-- Toast Notification -->
            <div id="toast" class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gray-800 dark:bg-white text-white dark:text-gray-900 px-4 py-2 rounded-full shadow-xl text-sm font-medium opacity-0 transition-opacity pointer-events-none z-50 flex items-center gap-2">
                <i class="fa-solid fa-circle-check text-green-400 dark:text-green-600"></i>
                <span id="toastMsg">Acción completada</span>
            </div>
            
            <!-- Context Action Tooltip -->
            <div id="actionTooltip" class="hidden absolute top-4 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg z-50 text-sm font-bold animate-pulse">
                <i class="fa-solid fa-location-dot mr-2"></i> Haz clic en el mapa para añadir un puesto
            </div>
        </main>
    </div>

    <!-- Hidden Link for Download -->
    <a id="downloadLink" class="hidden"></a>

    <script>
        // --- Database: Network Points (EMPTY START) ---
        let networkPoints = []; // User starts from scratch

        // --- Configuration & State ---
        const canvas = document.getElementById('designCanvas');
        const ctx = canvas.getContext('2d');
        const uploadInput = document.getElementById('uploadInput');
        const emptyState = document.getElementById('emptyState');
        const sizeSlider = document.getElementById('sizeSlider');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        let items = []; 
        let selectedItemId = null;
        let selectedNetworkPointId = null; 
        let backgroundImg = null;
        let isDarkMode = false;
        
        // Settings
        const ASSOCIATION_DIST = 100; // Pixels (scaled)
        const UPSCALE_FACTOR = 2; // Improve image quality by drawing on 2x canvas

        // Camera
        let camera = { x: 0, y: 0, zoom: 1 };
        let isDraggingCanvas = false;
        let lastMouseX = 0, lastMouseY = 0;

        // Interaction
        let isDraggingItem = false;
        let isNetworkMode = false;
        let isAddingPointMode = false; 
        let foundPoint = null; 

        // --- Initialization ---
        
        // Check system preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            toggleDarkMode();
        }

        uploadInput.addEventListener('change', handleImageUpload);
        canvas.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove); 
        window.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
        canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
        canvas.addEventListener('touchend', handleMouseUp);
        sizeSlider.addEventListener('input', handleResizeChange);
        searchInput.addEventListener('input', handleSearch);
        
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                if (selectedItemId !== null) deleteSelected();
                else if (selectedNetworkPointId !== null && isNetworkMode) deleteSelectedPoint();
            } else if (e.key === 'Escape') {
                if (isAddingPointMode) toggleAddPointMode();
            }
        });

        // --- Dark Mode ---
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.documentElement.classList.toggle('dark');
            draw(); // Redraw canvas (text colors might change)
        }

        // --- Drag and Drop from Sidebar ---
        function handleDragStart(e, type) {
            e.dataTransfer.setData("type", type);
        }

        function allowDrop(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            if (!backgroundImg) return showToast("Sube un plano primero", "error");

            const type = e.dataTransfer.getData("type");
            const rect = canvas.getBoundingClientRect();
            
            // Calculate scale of canvas vs display
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // Convert screen click to world coordinates
            const worldX = (clickX / camera.zoom) - camera.x;
            const worldY = (clickY / camera.zoom) - camera.y;

            addItem(type, worldX, worldY);
            
            // Auto-snap check
            const newItem = items[items.length - 1];
            const nearest = getNearestPoint(newItem);
            if (nearest && nearest.dist < ASSOCIATION_DIST) {
                // Optional: Snap to exact center of point?
                // newItem.x = nearest.point.x * canvas.width;
                // newItem.y = nearest.point.y * canvas.height - 40; 
                showToast(`Asignado a ${nearest.point.id}`);
            }
        }

        // --- Search Logic ---
        function handleSearch(e) {
            const query = e.target.value.toUpperCase().trim();
            searchResults.innerHTML = '';
            
            if (query.length === 0) {
                searchResults.classList.add('hidden');
                foundPoint = null;
                draw();
                return;
            }
            const matches = networkPoints.filter(p => p.id.toUpperCase().includes(query));
            if (matches.length > 0) {
                searchResults.classList.remove('hidden');
                matches.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'p-3 hover:bg-blue-50 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 flex justify-between items-center text-sm dark:text-gray-200';
                    div.innerHTML = `<span class="font-bold">${p.id}</span> <span class="text-xs text-blue-500">Ver <i class="fa-solid fa-arrow-right"></i></span>`;
                    div.onclick = () => focusOnPoint(p);
                    searchResults.appendChild(div);
                });
            } else {
                searchResults.innerHTML = '<div class="p-4 text-gray-400 text-center text-xs">No encontrado</div>';
                searchResults.classList.remove('hidden');
            }
        }

        function focusOnPoint(point) {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            foundPoint = point;
            searchResults.classList.add('hidden');
            searchInput.value = point.id;
            const targetZoom = 3;
            const pX = point.x * canvas.width;
            const pY = point.y * canvas.height;
            animateCameraTo((canvas.width/2/targetZoom)-pX, (canvas.height/2/targetZoom)-pY, targetZoom);
        }

        function animateCameraTo(targetX, targetY, targetZoom) {
            let steps = 20;
            let dx = (targetX - camera.x) / steps;
            let dy = (targetY - camera.y) / steps;
            let dz = (targetZoom - camera.zoom) / steps;
            function step() {
                camera.x += dx; camera.y += dy; camera.zoom += dz;
                draw();
                steps--;
                if(steps > 0) requestAnimationFrame(step);
            }
            step();
        }

        function getNearestPoint(item) {
            if (!backgroundImg) return null;
            let closest = null;
            let minDist = Infinity;
            networkPoints.forEach((p) => {
                const px = p.x * canvas.width;
                const py = p.y * canvas.height;
                const dist = Math.sqrt((item.x - px)**2 + (item.y - py)**2);
                if (dist < minDist) {
                    minDist = dist;
                    closest = p;
                }
            });
            if (minDist < ASSOCIATION_DIST * UPSCALE_FACTOR) { // Scale distance logic too
                return { point: closest, dist: minDist };
            }
            return null;
        }

        // --- Drawing ---

        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!backgroundImg) return;

            // Smooth scaling for images
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(camera.x, camera.y);

            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);

            items.filter(i => i.type === 'desk').forEach(item => drawItem(item));
            drawAssignments();

            if (isNetworkMode || isAddingPointMode || foundPoint) {
                drawNetworkPoints(1.0); 
            } else {
                drawNetworkPoints(0.4); 
            }

            items.filter(i => i.type !== 'desk').forEach(item => drawItem(item));

            if (foundPoint) {
                const px = foundPoint.x * canvas.width;
                const py = foundPoint.y * canvas.height;
                ctx.beginPath(); ctx.arc(px, py, 30 * UPSCALE_FACTOR, 0, Math.PI * 2);
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4 * UPSCALE_FACTOR; ctx.stroke();
            }

            ctx.restore();
            updateUI();
        }

        function drawAssignments() {
            items.forEach(item => {
                if (item.type === 'desk') return; 
                const nearest = getNearestPoint(item);
                if (nearest) {
                    const px = nearest.point.x * canvas.width;
                    const py = nearest.point.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.moveTo(item.x, item.y);
                    ctx.lineTo(px, py);
                    ctx.strokeStyle = isDarkMode ? 'rgba(96, 165, 250, 0.6)' : 'rgba(37, 99, 235, 0.6)'; 
                    ctx.lineWidth = (3 * UPSCALE_FACTOR) / camera.zoom;
                    ctx.setLineDash([10, 10]); 
                    ctx.stroke();
                    ctx.setLineDash([]); 
                    
                    ctx.beginPath();
                    ctx.arc(px, py, 5 * UPSCALE_FACTOR, 0, Math.PI*2);
                    ctx.fillStyle = '#2563eb';
                    ctx.fill();
                }
            });
        }

        function drawNetworkPoints(opacity = 0.8) {
            networkPoints.forEach(p => {
                const px = p.x * canvas.width;
                const py = p.y * canvas.height;
                const isSelected = p.id === selectedNetworkPointId;
                const isFound = foundPoint && foundPoint.id === p.id;
                
                const baseRadius = 8 * UPSCALE_FACTOR;

                ctx.beginPath();
                ctx.arc(px, py, (isSelected || isFound) ? baseRadius * 1.5 : baseRadius, 0, Math.PI * 2);
                ctx.fillStyle = (isSelected || isFound) ? '#ef4444' : `rgba(59, 130, 246, ${opacity})`;
                ctx.fill();
                
                if (isSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                if (isNetworkMode || isSelected || isFound || opacity > 0.5) {
                    ctx.font = `bold ${14 * UPSCALE_FACTOR}px Arial`;
                    ctx.textAlign = 'center';
                    const text = p.id;
                    const textMetrics = ctx.measureText(text);
                    const padding = 4 * UPSCALE_FACTOR;
                    
                    // Label Background
                    ctx.fillStyle = isDarkMode ? `rgba(15, 23, 42, ${opacity})` : `rgba(255,255,255,${opacity})`;
                    ctx.fillRect(px - textMetrics.width/2 - padding, py - (28 * UPSCALE_FACTOR), textMetrics.width + (padding*2), 18 * UPSCALE_FACTOR);
                    
                    // Label Text
                    ctx.fillStyle = (isSelected || isFound) ? '#ef4444' : (isDarkMode ? `rgba(147, 197, 253, ${opacity})` : `rgba(30, 58, 138, ${opacity})`);
                    ctx.fillText(text, px, py - (14 * UPSCALE_FACTOR));
                }
            });
        }

        function drawItem(item) {
            const isSelected = item.id === selectedItemId;
            ctx.save(); ctx.translate(item.x, item.y);
            
            // Adjust scale relative to upscale factor
            // Items need to be drawn larger because the canvas is larger
            const scale = UPSCALE_FACTOR;
            
            if (isSelected) {
                ctx.shadowColor = 'rgba(37, 99, 235, 0.6)'; ctx.shadowBlur = 20;
                ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 3 / camera.zoom;
                ctx.strokeRect((-item.width/2 * scale) - 5, (-item.height/2 * scale) - 5, (item.width * scale) + 10, (item.height * scale) + 10);
                ctx.shadowBlur = 0;
            }
            
            // Scale icon drawing
            ctx.scale(scale, scale);
            
            if (item.type === 'monitor') drawMonitorIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            else if (item.type === 'monitor-single') drawSingleMonitorIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            else if (item.type === 'dock') drawDockIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            else if (item.type === 'desk') drawDeskIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            
            ctx.restore();
        }

        // Icons (Colors adjusted for Dark Mode)
        function drawMonitorIcon(ctx, x, y, w, h) {
            const screenColor = isDarkMode ? '#334155' : '#1f2937'; 
            const innerColor = isDarkMode ? '#475569' : '#374151';
            
            const mw = (w / 2) - 2; const mh = h * 0.7;
            ctx.fillStyle = screenColor; ctx.fillRect(x, y, mw, mh);
            ctx.fillStyle = innerColor; ctx.fillRect(x+2, y+2, mw-4, mh-4);
            ctx.fillStyle = screenColor; ctx.fillRect(x + mw + 4, y, mw, mh); 
            ctx.fillStyle = innerColor; ctx.fillRect(x + mw + 6, y+2, mw-4, mh-4);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(x + w/2 - 2, y + mh, 4, h - mh); ctx.fillRect(x + w/2 - 8, y + h - 2, 16, 2); 
        }
        function drawSingleMonitorIcon(ctx, x, y, w, h) {
            const screenColor = isDarkMode ? '#1e40af' : '#1e3a8a';
            const innerColor = isDarkMode ? '#3b82f6' : '#3b82f6';
            const mh = h * 0.75; 
            ctx.fillStyle = screenColor; ctx.fillRect(x, y, w, mh);
            ctx.fillStyle = innerColor; ctx.fillRect(x+3, y+3, w-6, mh-6);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(x + w/2 - 3, y + mh, 6, h - mh); ctx.fillRect(x + w/2 - 10, y + h - 3, 20, 3); 
        }
        function drawDockIcon(ctx, x, y, w, h) {
            ctx.fillStyle = '#4f46e5'; ctx.beginPath(); ctx.roundRect(x, y + h/4, w, h/2, 4); ctx.fill();
            ctx.fillStyle = '#a5b4fc'; ctx.beginPath(); ctx.arc(x + w*0.3, y + h/2, w*0.05, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + w*0.6, y + h/2, w*0.05, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#312e81'; ctx.lineWidth = Math.max(1, w * 0.05); ctx.beginPath(); ctx.moveTo(x + w, y + h/2); ctx.lineTo(x + w + (w*0.15), y + h/2); ctx.stroke();
        }
        function drawDeskIcon(ctx, x, y, w, h) {
            ctx.fillStyle = isDarkMode ? '#854d0e' : '#d4a373'; 
            ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
            ctx.fillStyle = isDarkMode ? '#713f12' : '#c59263';
            ctx.fillRect(x, y + h - 5, w, 5);
        }

        // --- Logic ---

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImg = new Image();
                backgroundImg.onload = function() {
                    // UPSCALING LOGIC
                    canvas.width = backgroundImg.width * UPSCALE_FACTOR;
                    canvas.height = backgroundImg.height * UPSCALE_FACTOR;
                    
                    canvas.classList.remove('hidden');
                    emptyState.classList.add('hidden');
                    resetView();
                    showToast("Plano cargado y mejorado (2x)");
                }
                backgroundImg.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function screenToWorld(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;
            return { x: (canvasX / camera.zoom) - camera.x, y: (canvasY / camera.zoom) - camera.y };
        }

        function handleMouseDown(e) {
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const worldPos = screenToWorld(clientX, clientY);

            // Handle Add Point Mode
            if (isAddingPointMode) {
                const id = prompt("Ingresa el ID del nuevo puesto (ej: D-99):");
                if (id) {
                    networkPoints.push({
                        id: id.toUpperCase(),
                        x: worldPos.x / canvas.width,
                        y: worldPos.y / canvas.height
                    });
                    showToast("Puesto agregado: " + id);
                    draw();
                }
                return;
            }

            if (e.button === 2 || e.button === 1) {
                isDraggingCanvas = true; lastMouseX = clientX; lastMouseY = clientY;
                canvas.style.cursor = 'grabbing'; return;
            }

            // Check Items
            let clickedItem = null;
            // Scale hit detection because items are drawn larger
            const scale = UPSCALE_FACTOR;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (worldPos.x >= item.x - (item.width*scale)/2 && worldPos.x <= item.x + (item.width*scale)/2 &&
                    worldPos.y >= item.y - (item.height*scale)/2 && worldPos.y <= item.y + (item.height*scale)/2) {
                    clickedItem = item; break;
                }
            }

            // Check Points
            let clickedPoint = null;
             for (let i = 0; i < networkPoints.length; i++) {
                 const p = networkPoints[i];
                 const px = p.x * canvas.width;
                 const py = p.y * canvas.height;
                 if (Math.sqrt((worldPos.x - px)**2 + (worldPos.y - py)**2) < 25 * UPSCALE_FACTOR) {
                     clickedPoint = p; break;
                 }
             }

            if (clickedItem) {
                selectedItemId = clickedItem.id; selectedNetworkPointId = null;
                isDraggingItem = true; dragOffsetX = worldPos.x - clickedItem.x; dragOffsetY = worldPos.y - clickedItem.y;
                syncSliderToSelection();
            } else if (clickedPoint) {
                selectedNetworkPointId = clickedPoint.id; selectedItemId = null;
                if (isNetworkMode) isDraggingItem = true;
                // If not in network mode, we still select it to show name but don't drag
            } else {
                isDraggingCanvas = true; lastMouseX = clientX; lastMouseY = clientY;
                canvas.style.cursor = 'grabbing';
                selectedItemId = null; selectedNetworkPointId = null;
            }
            draw();
        }

        function handleMouseMove(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            if (isDraggingItem) {
                const worldPos = screenToWorld(clientX, clientY);
                if (selectedItemId) {
                    const item = items.find(i => i.id === selectedItemId);
                    if (item) { item.x = worldPos.x - dragOffsetX; item.y = worldPos.y - dragOffsetY; draw(); }
                } else if (selectedNetworkPointId && isNetworkMode) {
                    const point = networkPoints.find(p => p.id === selectedNetworkPointId);
                    if (point) { point.x = worldPos.x / canvas.width; point.y = worldPos.y / canvas.height; draw(); }
                }
            } else if (isDraggingCanvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const dx = (clientX - lastMouseX) * scaleX;
                const dy = (clientY - lastMouseY) * scaleY;
                camera.x += dx / camera.zoom; camera.y += dy / camera.zoom;
                lastMouseX = clientX; lastMouseY = clientY;
                draw();
            }
        }

        function handleMouseUp() { isDraggingItem = false; isDraggingCanvas = false; canvas.style.cursor = 'grab'; }
        function handleWheel(e) { e.preventDefault(); changeZoom(-e.deltaY * 0.001); }
        
        function changeZoom(delta) {
            if (!backgroundImg) return;
            const newZoom = Math.min(Math.max(camera.zoom + delta, 0.1), 5);
            const w = canvas.width; const h = canvas.height;
            const centerWx = (w/2 / camera.zoom) - camera.x;
            const centerWy = (h/2 / camera.zoom) - camera.y;
            camera.zoom = newZoom;
            camera.x = (w/2 / camera.zoom) - centerWx;
            camera.y = (h/2 / camera.zoom) - centerWy;
            draw();
        }
        function resetView() {
            if (!backgroundImg) return;
            camera = { x: 0, y: 0, zoom: 0.9 };
            camera.x = (canvas.width - canvas.width*0.9)/2 / 0.9;
            camera.y = (canvas.height - canvas.height*0.9)/2 / 0.9;
            draw();
        }
        function handleTouchStart(e) { if (e.touches.length === 1) handleMouseDown(e); }
        function handleTouchMove(e) { if (e.touches.length === 1) handleMouseMove(e); }

        function toggleAddPointMode() {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            isAddingPointMode = !isAddingPointMode;
            isNetworkMode = false; 
            updateModeUI();
            draw();
        }

        function toggleNetworkMode() {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            isNetworkMode = !isNetworkMode;
            isAddingPointMode = false;
            updateModeUI();
            draw();
        }

        function updateModeUI() {
            const addBtn = document.getElementById('addPointBtn');
            const editBtn = document.getElementById('toggleNetworkBtn');
            const modeText = document.getElementById('modeStatus');

            // Reset styles
            addBtn.className = addBtn.className.replace('ring-2 ring-blue-500 bg-blue-50', '');
            editBtn.className = editBtn.className.replace('ring-2 ring-blue-500 bg-blue-50', '');

            if(isAddingPointMode) {
                addBtn.className += ' ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900';
                modeText.innerText = "Haz CLIC en el mapa para añadir";
                modeText.className = "text-xs font-bold text-green-600 mt-2 text-center animate-pulse";
                canvas.style.cursor='crosshair';
            } else if(isNetworkMode) {
                editBtn.className += ' ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900';
                modeText.innerText = "Arrastra los círculos para moverlos";
                modeText.className = "text-xs font-bold text-blue-600 mt-2 text-center";
                canvas.style.cursor='move';
            } else {
                modeText.innerText = "Modo Navegación";
                modeText.className = "text-[10px] text-gray-400 mt-2 text-center";
                canvas.style.cursor='grab';
            }
        }

        function addItem(type, x, y) {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            const id = Date.now();
            let width = 30, height = 30;
            
            // Check current zoom to size items appropriately relative to the map
            // For now, fixed logic based on "average" map size
            
            if (type === 'monitor') { width = 60; height = 35; } 
            else if (type === 'monitor-single') { width = 35; height = 30; } 
            else if (type === 'desk') { width = 80; height = 45; }

            // x and y are passed from DragDrop or calculated center
            if (!x) {
                x = (canvas.width / 2 / camera.zoom) - camera.x;
                y = (canvas.height / 2 / camera.zoom) - camera.y;
            }

            items.push({ id, type, x, y, width, height, ratio: height/width });
            selectedItemId = id; selectedNetworkPointId = null;
            updateUI(); syncSliderToSelection(); draw();
        }

        function deleteSelected() { if(selectedItemId) { items = items.filter(i => i.id !== selectedItemId); selectedItemId = null; updateUI(); draw(); } }
        function deleteSelectedPoint() { 
            if(selectedNetworkPointId && confirm("¿Borrar el puesto "+selectedNetworkPointId+"?")) { 
                networkPoints = networkPoints.filter(p => p.id !== selectedNetworkPointId); 
                selectedNetworkPointId = null; 
                draw(); 
            } 
        }
        function handleResizeChange(e) { 
            if (!selectedItemId) return; 
            const item = items.find(i => i.id === selectedItemId); 
            if (item) { item.width = parseInt(e.target.value); item.height = item.width * item.ratio; draw(); } 
        }
        function syncSliderToSelection() {
            const item = items.find(i => i.id === selectedItemId);
            if (item) { 
                sizeSlider.value = item.width; 
                document.getElementById('sizeValueDisplay').innerText = item.width + 'px'; 
                
                if (item.type !== 'desk') {
                    const nearest = getNearestPoint(item);
                    const infoBox = document.getElementById('assignmentInfo');
                    if (nearest) {
                        infoBox.classList.remove('hidden');
                        document.getElementById('assignmentText').innerText = "Conectado a: " + nearest.point.id;
                    } else {
                        infoBox.classList.add('hidden');
                    }
                } else {
                     document.getElementById('assignmentInfo').classList.add('hidden');
                }
            }
        }

        function exportToExcel() {
            if (!backgroundImg) return showToast("Nada para exportar", "error");

            let report = networkPoints.map(p => ({
                id: p.id,
                dualMonitors: 0,
                singleMonitors: 0,
                docks: 0,
                desks: 0,
                totalScreens: 0
            }));

            items.forEach(item => {
                const nearest = getNearestPoint(item);
                if (nearest) {
                    const idx = networkPoints.findIndex(p => p.id === nearest.point.id);
                    if (idx !== -1) {
                        if (item.type === 'monitor') report[idx].dualMonitors++;
                        else if (item.type === 'monitor-single') report[idx].singleMonitors++;
                        else if (item.type === 'dock') report[idx].docks++;
                        else if (item.type === 'desk') report[idx].desks++;
                    }
                }
            });

            report.forEach(r => { r.totalScreens = (r.dualMonitors * 2) + r.singleMonitors; });

            const csvRows = [];
            csvRows.push(['Puesto ID', 'Escritorios', 'Kits Doble Monitor', 'Monitores Simples', 'Total Pantallas', 'Docking Stations']);
            report.forEach(r => {
                csvRows.push([r.id, r.desks, r.dualMonitors, r.singleMonitors, r.totalScreens, r.docks]);
            });

            const csvString = csvRows.map(e => e.join(",")).join("\n");
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", "inventario_oficina.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast("Excel descargado");
        }

        function exportImage() {
            if (!backgroundImg) return showToast("Nada para exportar", "error");
            const tempCam = {...camera};
            // Reset for export
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw pure image first
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
            
            // Draw elements
            items.filter(i => i.type === 'desk').forEach(item => {
                 ctx.save(); ctx.translate(item.x, item.y);
                 // Need to replicate scaling logic from drawItem for export
                 const scale = UPSCALE_FACTOR;
                 ctx.scale(scale, scale);
                 drawDeskIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
                 ctx.restore();
            });

            drawAssignments();
            drawNetworkPoints(0.6);
            
            items.filter(i => i.type !== 'desk').forEach(i => {
                 ctx.save(); ctx.translate(i.x, i.y);
                 const scale = UPSCALE_FACTOR;
                 ctx.scale(scale, scale);
                 if(i.type==='monitor') drawMonitorIcon(ctx, -i.width/2, -i.height/2, i.width, i.height);
                 else if(i.type==='monitor-single') drawSingleMonitorIcon(ctx, -i.width/2, -i.height/2, i.width, i.height);
                 else if(i.type==='dock') drawDockIcon(ctx, -i.width/2, -i.height/2, i.width, i.height);
                 ctx.restore();
            });

            const link = document.createElement('a');
            link.download = 'layout_oficina.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            // Restore view
            camera = tempCam; draw();
            showToast("Imagen descargada");
        }

        function updateUI() {
            const dual = items.filter(i => i.type === 'monitor').length;
            const single = items.filter(i => i.type === 'monitor-single').length;
            const docks = items.filter(i => i.type === 'dock').length;
            const desks = items.filter(i => i.type === 'desk').length;
            
            document.getElementById('count-monitor').innerText = dual;
            document.getElementById('count-monitor-single').innerText = single;
            document.getElementById('count-dock').innerText = docks;
            document.getElementById('count-desk').innerText = desks;
            
            const selControls = document.getElementById('selectionControls');
            
            if (selectedItemId) {
                selControls.classList.remove('opacity-50', 'pointer-events-none');
            } else {
                selControls.classList.add('opacity-50', 'pointer-events-none');
            }
        }

        function showToast(msg, type='success') {
            const t = document.getElementById('toast');
            document.getElementById('toastMsg').innerText = msg;
            t.classList.remove('opacity-0');
            setTimeout(() => t.classList.add('opacity-0'), 3000);
        }
        
        canvas.addEventListener('contextmenu', event => event.preventDefault());
    </script>
</body>
</html>
