<!DOCTYPE html>
<html lang="es" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Manager: Pro & Database</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f172a',
                            surface: '#1e293b',
                            border: '#334155',
                            text: '#f8fafc',
                            textMuted: '#94a3b8'
                        }
                    }
                }
            }
        }
    </script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; transition: background-color 0.3s, color 0.3s; }
        
        .bg-grid {
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .dark .bg-grid {
            background-image: radial-gradient(#334155 1px, transparent 1px);
        }

        .tool-btn { transition: all 0.2s; cursor: grab; }
        .tool-btn:active { cursor: grabbing; transform: scale(0.98); }
        .tool-active { background-color: #eff6ff; border-color: #3b82f6; color: #1d4ed8; }
        .dark .tool-active { background-color: #1e3a8a; border-color: #3b82f6; color: #93c5fd; }
        
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #2563eb; cursor: pointer; margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #bfdbfe; border-radius: 2px;
        }
        .dark input[type=range]::-webkit-slider-thumb { background: #60a5fa; }
        .dark input[type=range]::-webkit-slider-runnable-track { background: #475569; }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-dark-bg text-gray-800 dark:text-dark-text h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white dark:bg-dark-surface shadow-md z-20 p-3 flex justify-between items-center relative border-b dark:border-dark-border transition-colors">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 text-white p-2 rounded-lg shadow-lg shadow-blue-500/30">
                <i class="fa-solid fa-server"></i>
            </div>
            <div>
                <h1 class="font-bold text-lg leading-tight">Office Manager</h1>
                <p class="text-xs text-gray-500 dark:text-dark-textMuted">Diseño & Base de Datos</p>
            </div>
        </div>

        <!-- Search Bar -->
        <div class="absolute left-1/2 transform -translate-x-1/2 w-1/3 min-w-[300px]">
            <div class="relative group">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <i class="fa-solid fa-magnifying-glass text-gray-400 group-focus-within:text-blue-500 transition-colors"></i>
                </div>
                <input type="text" id="searchInput" 
                    class="block w-full pl-10 pr-4 py-2 border-2 border-gray-100 dark:border-gray-700 rounded-full leading-5 bg-gray-50 dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-400 focus:outline-none focus:bg-white dark:focus:bg-gray-700 focus:border-blue-500 transition-all shadow-sm" 
                    placeholder="Buscar puesto (ej: D-12)..." autocomplete="off">
                <div id="searchResults" class="hidden absolute top-full left-0 w-full bg-white dark:bg-dark-surface mt-2 rounded-xl shadow-xl border border-gray-100 dark:border-dark-border overflow-hidden z-50 max-h-60 overflow-y-auto"></div>
            </div>
        </div>

        <div class="flex gap-2 items-center">
            <button onclick="toggleDarkMode()" class="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-yellow-400 flex items-center justify-center hover:bg-gray-300 dark:hover:bg-gray-600 transition mr-2" title="Modo Oscuro/Claro">
                <i class="fa-solid fa-moon dark:hidden"></i>
                <i class="fa-solid fa-sun hidden dark:block"></i>
            </button>

            <!-- File Inputs -->
            <input type="file" id="uploadInput" accept="image/*" class="hidden">
            <input type="file" id="loadProjectInput" accept=".json" class="hidden">

            <!-- Database Buttons -->
            <div class="flex bg-gray-100 dark:bg-gray-800 rounded-lg p-1 mr-2 border border-gray-200 dark:border-gray-600">
                <button onclick="document.getElementById('loadProjectInput').click()" class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-white dark:hover:bg-gray-700 hover:shadow-sm transition flex items-center gap-2" title="Cargar archivo de proyecto">
                    <i class="fa-solid fa-folder-open text-yellow-600 dark:text-yellow-500"></i> Cargar
                </button>
                <div class="w-px bg-gray-300 dark:bg-gray-600 mx-1"></div>
                <button onclick="saveProject()" class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-white dark:hover:bg-gray-700 hover:shadow-sm transition flex items-center gap-2" title="Guardar proyecto como archivo">
                    <i class="fa-solid fa-floppy-disk text-blue-600 dark:text-blue-500"></i> Guardar
                </button>
            </div>

            <!-- Export Actions -->
            <button onclick="exportToExcel()" class="bg-green-600 text-white px-3 py-2 rounded-lg font-medium hover:bg-green-700 transition shadow-sm text-sm flex items-center gap-2">
                <i class="fa-solid fa-file-excel"></i> <span class="hidden sm:inline">Excel</span>
            </button>
            <button onclick="exportImage()" class="bg-indigo-600 text-white px-3 py-2 rounded-lg font-medium hover:bg-indigo-700 transition shadow-sm text-sm">
                <i class="fa-solid fa-image"></i>
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Sidebar Tools -->
        <aside class="w-72 bg-white dark:bg-dark-surface border-r border-gray-200 dark:border-dark-border flex flex-col shadow-lg z-10 overflow-y-auto transition-colors" id="sidebar">
            
            <!-- Map Controls -->
            <div class="p-4 border-b border-gray-100 dark:border-dark-border bg-gray-50 dark:bg-gray-800/50">
                <h3 class="font-bold text-gray-800 dark:text-gray-200 text-sm mb-3 flex items-center gap-2">
                    <i class="fa-solid fa-map-pin text-red-500"></i> Puestos de Red
                </h3>
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <button id="addPointBtn" onclick="toggleAddPointMode()" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-200 py-2 px-2 rounded-lg text-xs font-bold hover:bg-blue-50 dark:hover:bg-blue-900 hover:text-blue-600 hover:border-blue-300 transition flex flex-col items-center gap-1 shadow-sm">
                        <i class="fa-solid fa-plus-circle text-lg"></i> Crear Puesto
                    </button>
                    <button id="toggleNetworkBtn" onclick="toggleNetworkMode()" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-200 py-2 px-2 rounded-lg text-xs font-bold hover:bg-blue-50 dark:hover:bg-blue-900 hover:text-blue-600 hover:border-blue-300 transition flex flex-col items-center gap-1 shadow-sm">
                        <i class="fa-regular fa-eye text-lg"></i> Editar/Mover
                    </button>
                </div>
                <p class="text-[10px] text-gray-400 leading-tight mt-2 text-center">
                    <span id="modeStatus">Haz clic en "Crear Puesto" para empezar</span>
                </p>
            </div>

            <!-- Draggable Tools -->
            <div class="p-4 space-y-3 flex-1">
                <h3 class="font-semibold text-gray-400 text-xs uppercase tracking-wider mb-2">Arrastra al Mapa</h3>
                
                <div draggable="true" ondragstart="handleDragStart(event, 'desk')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-orange-100 dark:border-orange-900/30 hover:border-orange-400 hover:bg-orange-50 dark:hover:bg-orange-900/50 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm mb-4 select-none">
                    <div class="w-10 h-10 bg-orange-100 dark:bg-orange-900/50 rounded-lg flex items-center justify-center text-orange-600 dark:text-orange-400">
                        <i class="fa-solid fa-table"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Escritorio</div>
                        <div class="text-[10px] text-gray-400">Mobiliario</div>
                    </div>
                </div>

                <div class="h-px bg-gray-100 dark:bg-gray-700 my-2"></div>

                <div draggable="true" ondragstart="handleDragStart(event, 'monitor')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/30 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm select-none">
                    <div class="w-10 h-10 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-600 dark:text-gray-300 group-hover:text-blue-600">
                        <i class="fa-solid fa-desktop"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Doble Monitor</div>
                        <div class="text-[10px] text-gray-400">Kit Estándar</div>
                    </div>
                </div>

                <div draggable="true" ondragstart="handleDragStart(event, 'monitor-single')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/30 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm select-none">
                    <div class="w-10 h-10 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-600 dark:text-gray-300 group-hover:text-blue-500">
                        <i class="fa-solid fa-tv"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Monitor Simple</div>
                        <div class="text-[10px] text-gray-400">Kit Básico</div>
                    </div>
                </div>

                <div draggable="true" ondragstart="handleDragStart(event, 'dock')" class="tool-btn w-full bg-white dark:bg-gray-800 border-2 border-gray-100 dark:border-gray-700 hover:border-indigo-500 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 text-left p-3 rounded-xl flex items-center gap-3 group shadow-sm select-none">
                    <div class="w-10 h-10 bg-gray-100 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-600 dark:text-gray-300 group-hover:text-indigo-500">
                        <i class="fa-solid fa-plug"></i>
                    </div>
                    <div>
                        <div class="font-bold text-gray-700 dark:text-gray-200 text-sm">Docking Station</div>
                        <div class="text-[10px] text-gray-400">USB-C Hub</div>
                    </div>
                </div>

                <!-- Selection Controls -->
                <div id="selectionControls" class="opacity-50 pointer-events-none transition-all duration-200 bg-gray-50 dark:bg-gray-800 p-4 rounded-xl border border-gray-200 dark:border-gray-700 mt-4">
                    <p class="text-xs font-bold text-gray-500 dark:text-gray-400 mb-2 uppercase flex justify-between">
                        Editar Selección
                    </p>
                    
                    <div id="assignmentInfo" class="mb-3 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 p-2 rounded border border-blue-200 dark:border-blue-700 hidden">
                        <i class="fa-solid fa-link mr-1"></i> <span id="assignmentText">Sin asignar</span>
                    </div>

                    <!-- Size Slider -->
                    <div class="mb-3">
                        <label class="flex justify-between text-xs text-gray-600 dark:text-gray-400 mb-1 font-semibold">
                            <span>Tamaño</span>
                            <span id="sizeValueDisplay">100%</span>
                        </label>
                        <input type="range" id="sizeSlider" min="20" max="300" value="60" class="w-full h-2 bg-blue-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <!-- Rotation Slider -->
                    <div class="mb-4">
                        <label class="flex justify-between text-xs text-gray-600 dark:text-gray-400 mb-1 font-semibold">
                            <span>Rotación</span>
                            <span id="rotationValueDisplay">0°</span>
                        </label>
                        <input type="range" id="rotationSlider" min="0" max="360" value="0" class="w-full h-2 bg-green-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="duplicateSelected()" class="bg-white dark:bg-gray-700 text-blue-600 dark:text-blue-400 border border-blue-200 dark:border-blue-900/50 hover:bg-blue-50 dark:hover:bg-blue-900/30 p-2 rounded-lg flex items-center justify-center gap-1 font-medium text-xs shadow-sm transition" title="Tecla: D">
                            <i class="fa-regular fa-copy"></i> Duplicar
                        </button>
                        <button onclick="deleteSelected()" class="bg-white dark:bg-gray-700 text-red-600 dark:text-red-400 border border-red-200 dark:border-red-900/50 hover:bg-red-50 dark:hover:bg-red-900/30 p-2 rounded-lg flex items-center justify-center gap-1 font-medium text-xs shadow-sm transition">
                            <i class="fa-solid fa-trash"></i> Borrar
                        </button>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="mt-auto bg-slate-800 dark:bg-slate-900 text-white p-4 text-center border-t border-slate-700">
                <button onclick="resetView()" class="text-xs text-slate-400 hover:text-white mb-2 flex items-center justify-center gap-1 w-full">
                    <i class="fa-solid fa-compress-arrows-alt"></i> Centrar Mapa
                </button>
                <div class="grid grid-cols-4 gap-1">
                    <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-blue-400 text-sm" id="count-monitor">0</div>
                        <div class="text-[9px] text-slate-300">Dual</div>
                    </div>
                     <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-blue-300 text-sm" id="count-monitor-single">0</div>
                        <div class="text-[9px] text-slate-300">Simp</div>
                    </div>
                    <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-indigo-400 text-sm" id="count-dock">0</div>
                        <div class="text-[9px] text-slate-300">Dock</div>
                    </div>
                     <div class="bg-slate-700 dark:bg-slate-800 rounded p-1">
                        <div class="font-bold text-orange-400 text-sm" id="count-desk">0</div>
                        <div class="text-[9px] text-slate-300">Mesa</div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Canvas -->
        <main class="flex-1 bg-gray-200 dark:bg-gray-900 relative overflow-hidden cursor-grab active:cursor-grabbing bg-grid" id="canvasContainer">
            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 pointer-events-none z-0">
                <div class="bg-white dark:bg-gray-800 p-8 rounded-full shadow-lg mb-4 animate-bounce">
                    <i class="fa-regular fa-map text-6xl text-blue-200 dark:text-blue-900"></i>
                </div>
                <h2 class="text-2xl font-bold text-gray-600 dark:text-gray-300">Bienvenido al Office Manager</h2>
                <p class="text-gray-500 dark:text-gray-500 mt-2 text-center max-w-md">
                    Sube un plano nuevo o carga un proyecto existente<br>para continuar trabajando.
                </p>
                <div class="flex gap-3 mt-6 pointer-events-auto">
                    <button onclick="document.getElementById('uploadInput').click()" class="bg-blue-600 text-white px-6 py-3 rounded-xl font-bold hover:bg-blue-700 shadow-lg transition hover:scale-105 transform duration-200">
                        <i class="fa-solid fa-image mr-2"></i> Nuevo Plano
                    </button>
                    <button onclick="document.getElementById('loadProjectInput').click()" class="bg-white dark:bg-gray-700 text-gray-700 dark:text-white px-6 py-3 rounded-xl font-bold hover:bg-gray-50 dark:hover:bg-gray-600 shadow-lg border border-gray-200 dark:border-gray-600 transition hover:scale-105 transform duration-200">
                        <i class="fa-solid fa-folder-open mr-2 text-yellow-500"></i> Cargar Proyecto
                    </button>
                </div>
            </div>
            <canvas id="designCanvas" class="absolute top-0 left-0 hidden shadow-2xl transition-opacity duration-300" ondragover="allowDrop(event)" ondrop="handleDrop(event)"></canvas>
            
            <div class="absolute bottom-6 right-6 flex flex-col gap-2 z-10">
                <button onclick="changeZoom(0.1)" class="w-10 h-10 bg-white dark:bg-gray-800 rounded-lg shadow-lg text-gray-600 dark:text-gray-300 hover:text-blue-600 hover:bg-blue-50 flex items-center justify-center font-bold text-xl transition transform hover:scale-105 border border-gray-200 dark:border-gray-700">+</button>
                <button onclick="changeZoom(-0.1)" class="w-10 h-10 bg-white dark:bg-gray-800 rounded-lg shadow-lg text-gray-600 dark:text-gray-300 hover:text-blue-600 hover:bg-blue-50 flex items-center justify-center font-bold text-xl transition transform hover:scale-105 border border-gray-200 dark:border-gray-700">-</button>
            </div>
            <div id="toast" class="absolute top-6 left-1/2 transform -translate-x-1/2 bg-gray-800 dark:bg-white text-white dark:text-gray-900 px-4 py-2 rounded-full shadow-xl text-sm font-medium opacity-0 transition-opacity pointer-events-none z-50 flex items-center gap-2">
                <i class="fa-solid fa-circle-check text-green-400 dark:text-green-600"></i>
                <span id="toastMsg">Acción completada</span>
            </div>
        </main>
    </div>

    <script>
        let networkPoints = []; 

        const canvas = document.getElementById('designCanvas');
        const ctx = canvas.getContext('2d');
        const uploadInput = document.getElementById('uploadInput');
        const loadProjectInput = document.getElementById('loadProjectInput');
        const emptyState = document.getElementById('emptyState');
        const sizeSlider = document.getElementById('sizeSlider');
        const rotationSlider = document.getElementById('rotationSlider');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        let items = []; 
        let selectedItemId = null;
        let selectedNetworkPointId = null; 
        let backgroundImg = null;
        let isDarkMode = false;
        
        const ASSOCIATION_DIST = 100;
        const UPSCALE_FACTOR = 2;

        let camera = { x: 0, y: 0, zoom: 1 };
        let isDraggingCanvas = false;
        let lastMouseX = 0, lastMouseY = 0;

        let isDraggingItem = false;
        let isNetworkMode = false;
        let isAddingPointMode = false; 
        let foundPoint = null; 

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            toggleDarkMode();
        }

        uploadInput.addEventListener('change', handleImageUpload);
        loadProjectInput.addEventListener('change', handleProjectLoad);
        canvas.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove); 
        window.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        
        canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
        canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
        canvas.addEventListener('touchend', handleMouseUp);
        
        sizeSlider.addEventListener('input', handleResizeChange);
        rotationSlider.addEventListener('input', handleRotationChange);
        searchInput.addEventListener('input', handleSearch);
        
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                if (selectedItemId !== null) deleteSelected();
                else if (selectedNetworkPointId !== null && isNetworkMode) deleteSelectedPoint();
            } else if (e.key === 'Escape') {
                if (isAddingPointMode) toggleAddPointMode();
            } else if (e.key.toLowerCase() === 'd' && selectedItemId) {
                duplicateSelected();
            }
        });

        // --- Database / File System Functions ---

        function saveProject() {
            if (!backgroundImg) return showToast("No hay proyecto activo para guardar", "error");
            
            // Create data package
            const projectData = {
                version: "1.0",
                timestamp: Date.now(),
                networkPoints: networkPoints,
                items: items,
                imageData: backgroundImg.src // Saves the base64 image data
            };
            
            // Create Blob and Link
            const blob = new Blob([JSON.stringify(projectData)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            const date = new Date();
            const dateStr = `${date.getFullYear()}-${(date.getMonth()+1).toString().padStart(2,'0')}-${date.getDate()}`;
            
            link.href = url;
            link.download = `oficina_proyecto_${dateStr}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast("Proyecto guardado exitosamente (.json)");
        }

        function handleProjectLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    if (data.imageData) {
                        // Load image first
                        backgroundImg = new Image();
                        backgroundImg.onload = function() {
                            canvas.width = backgroundImg.width * UPSCALE_FACTOR; // Should match save ratio if stored raw, or just logic
                            // Actually if src is dataURL, width/height are inherent.
                            // We re-apply upscale logic assuming user wants high res
                            // Note: if user uploaded raw image before, data.imageData is that.
                            // We treat it as a fresh image load effectively.
                            // BUT wait, items coordinates are based on the previous canvas size.
                            // If we change UPSCALE_FACTOR between versions it might break.
                            // For this single file app, logic is consistent.
                            
                            // Re-calculate dimensions based on current logic
                            canvas.width = backgroundImg.width * UPSCALE_FACTOR;
                            canvas.height = backgroundImg.height * UPSCALE_FACTOR;
                            
                            canvas.classList.remove('hidden');
                            emptyState.classList.add('hidden');
                            
                            // Restore Data
                            networkPoints = data.networkPoints || [];
                            items = data.items || [];
                            
                            resetView();
                            showToast("Proyecto cargado exitosamente");
                        };
                        backgroundImg.src = data.imageData;
                    } else {
                        showToast("El archivo no contiene imagen de fondo", "error");
                    }
                } catch (err) {
                    console.error(err);
                    showToast("Error al leer el archivo de proyecto", "error");
                }
            };
            reader.readAsText(file);
            // Reset input so same file can be selected again
            e.target.value = '';
        }

        // --- Core Functions ---

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.documentElement.classList.toggle('dark');
            draw();
        }

        function handleDragStart(e, type) { e.dataTransfer.setData("type", type); }
        function allowDrop(e) { e.preventDefault(); }
        
        function handleDrop(e) {
            e.preventDefault();
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            const type = e.dataTransfer.getData("type");
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;
            const worldX = (clickX / camera.zoom) - camera.x;
            const worldY = (clickY / camera.zoom) - camera.y;
            addItem(type, worldX, worldY);
        }

        function handleSearch(e) {
            const query = e.target.value.toUpperCase().trim();
            searchResults.innerHTML = '';
            if (query.length === 0) { searchResults.classList.add('hidden'); foundPoint = null; draw(); return; }
            const matches = networkPoints.filter(p => p.id.toUpperCase().includes(query));
            if (matches.length > 0) {
                searchResults.classList.remove('hidden');
                matches.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'p-3 hover:bg-blue-50 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 flex justify-between items-center text-sm dark:text-gray-200';
                    div.innerHTML = `<span class="font-bold">${p.id}</span> <span class="text-xs text-blue-500">Ver <i class="fa-solid fa-arrow-right"></i></span>`;
                    div.onclick = () => focusOnPoint(p);
                    searchResults.appendChild(div);
                });
            } else {
                searchResults.innerHTML = '<div class="p-4 text-gray-400 text-center text-xs">No encontrado</div>';
                searchResults.classList.remove('hidden');
            }
        }

        function focusOnPoint(point) {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            foundPoint = point;
            searchResults.classList.add('hidden');
            searchInput.value = point.id;
            const targetZoom = 3;
            const pX = point.x * canvas.width;
            const pY = point.y * canvas.height;
            animateCameraTo((canvas.width/2/targetZoom)-pX, (canvas.height/2/targetZoom)-pY, targetZoom);
        }

        function animateCameraTo(targetX, targetY, targetZoom) {
            let steps = 20;
            let dx = (targetX - camera.x) / steps;
            let dy = (targetY - camera.y) / steps;
            let dz = (targetZoom - camera.zoom) / steps;
            function step() { camera.x += dx; camera.y += dy; camera.zoom += dz; draw(); steps--; if(steps > 0) requestAnimationFrame(step); }
            step();
        }

        function getNearestPoint(item) {
            if (!backgroundImg) return null;
            let closest = null; let minDist = Infinity;
            networkPoints.forEach((p) => {
                const px = p.x * canvas.width; const py = p.y * canvas.height;
                const dist = Math.sqrt((item.x - px)**2 + (item.y - py)**2);
                if (dist < minDist) { minDist = dist; closest = p; }
            });
            if (minDist < ASSOCIATION_DIST * UPSCALE_FACTOR) { return { point: closest, dist: minDist }; }
            return null;
        }

        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!backgroundImg) return;
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.save();
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(camera.x, camera.y);
            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);

            items.filter(i => i.type === 'desk').forEach(item => drawItem(item));
            drawAssignments();
            if (isNetworkMode || isAddingPointMode || foundPoint) drawNetworkPoints(1.0); else drawNetworkPoints(0.4);
            items.filter(i => i.type !== 'desk').forEach(item => drawItem(item));

            if (foundPoint) {
                const px = foundPoint.x * canvas.width;
                const py = foundPoint.y * canvas.height;
                ctx.beginPath(); ctx.arc(px, py, 30 * UPSCALE_FACTOR, 0, Math.PI * 2);
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 4 * UPSCALE_FACTOR; ctx.stroke();
            }
            ctx.restore();
            updateUI();
        }

        function drawAssignments() {
            items.forEach(item => {
                if (item.type === 'desk') return; 
                const nearest = getNearestPoint(item);
                if (nearest) {
                    const px = nearest.point.x * canvas.width;
                    const py = nearest.point.y * canvas.height;
                    ctx.beginPath(); ctx.moveTo(item.x, item.y); ctx.lineTo(px, py);
                    ctx.strokeStyle = isDarkMode ? 'rgba(96, 165, 250, 0.6)' : 'rgba(37, 99, 235, 0.6)'; 
                    ctx.lineWidth = (3 * UPSCALE_FACTOR) / camera.zoom;
                    ctx.setLineDash([10, 10]); ctx.stroke(); ctx.setLineDash([]); 
                    ctx.beginPath(); ctx.arc(px, py, 5 * UPSCALE_FACTOR, 0, Math.PI*2); ctx.fillStyle = '#2563eb'; ctx.fill();
                }
            });
        }

        function drawNetworkPoints(opacity = 0.8) {
            networkPoints.forEach(p => {
                const px = p.x * canvas.width; const py = p.y * canvas.height;
                const isSelected = p.id === selectedNetworkPointId;
                const isFound = foundPoint && foundPoint.id === p.id;
                const baseRadius = 8 * UPSCALE_FACTOR;
                ctx.beginPath(); ctx.arc(px, py, (isSelected || isFound) ? baseRadius * 1.5 : baseRadius, 0, Math.PI * 2);
                ctx.fillStyle = (isSelected || isFound) ? '#ef4444' : `rgba(59, 130, 246, ${opacity})`;
                ctx.fill();
                if (isSelected) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke(); }
                if (isNetworkMode || isSelected || isFound || opacity > 0.5) {
                    ctx.font = `bold ${14 * UPSCALE_FACTOR}px Arial`; ctx.textAlign = 'center';
                    const text = p.id; const tm = ctx.measureText(text); const pad = 4 * UPSCALE_FACTOR;
                    ctx.fillStyle = isDarkMode ? `rgba(15, 23, 42, ${opacity})` : `rgba(255,255,255,${opacity})`;
                    ctx.fillRect(px - tm.width/2 - pad, py - (28 * UPSCALE_FACTOR), tm.width + (pad*2), 18 * UPSCALE_FACTOR);
                    ctx.fillStyle = (isSelected || isFound) ? '#ef4444' : (isDarkMode ? `rgba(147, 197, 253, ${opacity})` : `rgba(30, 58, 138, ${opacity})`);
                    ctx.fillText(text, px, py - (14 * UPSCALE_FACTOR));
                }
            });
        }

        function drawItem(item) {
            const isSelected = item.id === selectedItemId;
            ctx.save();
            ctx.translate(item.x, item.y);
            if (item.rotation) ctx.rotate(item.rotation * Math.PI / 180);
            const scale = UPSCALE_FACTOR;
            if (isSelected) {
                ctx.shadowColor = 'rgba(37, 99, 235, 0.6)'; ctx.shadowBlur = 20;
                ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 3 / camera.zoom;
                ctx.strokeRect((-item.width/2 * scale) - 5, (-item.height/2 * scale) - 5, (item.width * scale) + 10, (item.height * scale) + 10);
                ctx.shadowBlur = 0;
            }
            ctx.scale(scale, scale);
            if (item.type === 'monitor') drawMonitorIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            else if (item.type === 'monitor-single') drawSingleMonitorIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            else if (item.type === 'dock') drawDockIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            else if (item.type === 'desk') drawDeskIcon(ctx, -item.width/2, -item.height/2, item.width, item.height);
            ctx.restore();
        }

        function drawMonitorIcon(ctx, x, y, w, h) {
            const sc = isDarkMode ? '#334155' : '#1f2937'; const ic = isDarkMode ? '#475569' : '#374151';
            const mw = (w / 2) - 2; const mh = h * 0.7;
            ctx.fillStyle = sc; ctx.fillRect(x, y, mw, mh); ctx.fillStyle = ic; ctx.fillRect(x+2, y+2, mw-4, mh-4);
            ctx.fillStyle = sc; ctx.fillRect(x + mw + 4, y, mw, mh); ctx.fillStyle = ic; ctx.fillRect(x + mw + 6, y+2, mw-4, mh-4);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(x + w/2 - 2, y + mh, 4, h - mh); ctx.fillRect(x + w/2 - 8, y + h - 2, 16, 2); 
        }
        function drawSingleMonitorIcon(ctx, x, y, w, h) {
            const sc = isDarkMode ? '#1e40af' : '#1e3a8a'; const ic = isDarkMode ? '#3b82f6' : '#3b82f6';
            const mh = h * 0.75; 
            ctx.fillStyle = sc; ctx.fillRect(x, y, w, mh); ctx.fillStyle = ic; ctx.fillRect(x+3, y+3, w-6, mh-6);
            ctx.fillStyle = '#9ca3af'; ctx.fillRect(x + w/2 - 3, y + mh, 6, h - mh); ctx.fillRect(x + w/2 - 10, y + h - 3, 20, 3); 
        }
        function drawDockIcon(ctx, x, y, w, h) {
            ctx.fillStyle = '#4f46e5'; ctx.beginPath(); ctx.roundRect(x, y + h/4, w, h/2, 4); ctx.fill();
            ctx.fillStyle = '#a5b4fc'; ctx.beginPath(); ctx.arc(x + w*0.3, y + h/2, w*0.05, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + w*0.6, y + h/2, w*0.05, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#312e81'; ctx.lineWidth = Math.max(1, w * 0.05); ctx.beginPath(); ctx.moveTo(x + w, y + h/2); ctx.lineTo(x + w + (w*0.15), y + h/2); ctx.stroke();
        }
        function drawDeskIcon(ctx, x, y, w, h) {
            ctx.fillStyle = isDarkMode ? '#854d0e' : '#d4a373'; ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
            ctx.fillStyle = isDarkMode ? '#713f12' : '#c59263'; ctx.fillRect(x, y + h - 5, w, 5);
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImg = new Image();
                backgroundImg.onload = function() {
                    canvas.width = backgroundImg.width * UPSCALE_FACTOR;
                    canvas.height = backgroundImg.height * UPSCALE_FACTOR;
                    canvas.classList.remove('hidden');
                    emptyState.classList.add('hidden');
                    resetView();
                    showToast("Plano cargado y mejorado (2x)");
                }
                backgroundImg.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function screenToWorld(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;
            return { x: (canvasX / camera.zoom) - camera.x, y: (canvasY / camera.zoom) - camera.y };
        }

        function handleMouseDown(e) {
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const worldPos = screenToWorld(clientX, clientY);

            if (isAddingPointMode) {
                const id = prompt("Ingresa el ID del nuevo puesto (ej: D-99):");
                if (id) {
                    networkPoints.push({ id: id.toUpperCase(), x: worldPos.x / canvas.width, y: worldPos.y / canvas.height });
                    showToast("Puesto agregado: " + id);
                    draw();
                }
                return;
            }
            if (e.button === 2 || e.button === 1) { isDraggingCanvas = true; lastMouseX = clientX; lastMouseY = clientY; canvas.style.cursor = 'grabbing'; return; }

            let clickedItem = null;
            const scale = UPSCALE_FACTOR;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (worldPos.x >= item.x - (item.width*scale)/2 && worldPos.x <= item.x + (item.width*scale)/2 &&
                    worldPos.y >= item.y - (item.height*scale)/2 && worldPos.y <= item.y + (item.height*scale)/2) {
                    clickedItem = item; break;
                }
            }

            let clickedPoint = null;
             for (let i = 0; i < networkPoints.length; i++) {
                 const p = networkPoints[i];
                 const px = p.x * canvas.width; const py = p.y * canvas.height;
                 if (Math.sqrt((worldPos.x - px)**2 + (worldPos.y - py)**2) < 25 * UPSCALE_FACTOR) { clickedPoint = p; break; }
             }

            if (clickedItem) {
                selectedItemId = clickedItem.id; selectedNetworkPointId = null;
                isDraggingItem = true; dragOffsetX = worldPos.x - clickedItem.x; dragOffsetY = worldPos.y - clickedItem.y;
                syncSliderToSelection();
            } else if (clickedPoint) {
                selectedNetworkPointId = clickedPoint.id; selectedItemId = null;
                if (isNetworkMode) isDraggingItem = true;
            } else {
                isDraggingCanvas = true; lastMouseX = clientX; lastMouseY = clientY;
                canvas.style.cursor = 'grabbing';
                selectedItemId = null; selectedNetworkPointId = null;
            }
            draw();
        }

        function handleMouseMove(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            if (isDraggingItem) {
                const worldPos = screenToWorld(clientX, clientY);
                if (selectedItemId) {
                    const item = items.find(i => i.id === selectedItemId);
                    if (item) { item.x = worldPos.x - dragOffsetX; item.y = worldPos.y - dragOffsetY; draw(); }
                } else if (selectedNetworkPointId && isNetworkMode) {
                    const point = networkPoints.find(p => p.id === selectedNetworkPointId);
                    if (point) { point.x = worldPos.x / canvas.width; point.y = worldPos.y / canvas.height; draw(); }
                }
            } else if (isDraggingCanvas) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const dx = (clientX - lastMouseX) * scaleX;
                const dy = (clientY - lastMouseY) * scaleY;
                camera.x += dx / camera.zoom; camera.y += dy / camera.zoom;
                lastMouseX = clientX; lastMouseY = clientY;
                draw();
            }
        }

        function handleMouseUp() { isDraggingItem = false; isDraggingCanvas = false; canvas.style.cursor = 'grab'; }
        function handleWheel(e) { e.preventDefault(); changeZoom(-e.deltaY * 0.001); }
        function handleTouchStart(e) { if (e.touches.length === 1) handleMouseDown(e); }
        function handleTouchMove(e) { if (e.touches.length === 1) handleMouseMove(e); }

        function toggleAddPointMode() { if (!backgroundImg) return showToast("Sube un plano primero", "error"); isAddingPointMode = !isAddingPointMode; isNetworkMode = false; updateModeUI(); draw(); }
        function toggleNetworkMode() { if (!backgroundImg) return showToast("Sube un plano primero", "error"); isNetworkMode = !isNetworkMode; isAddingPointMode = false; updateModeUI(); draw(); }

        function updateModeUI() {
            const addBtn = document.getElementById('addPointBtn');
            const editBtn = document.getElementById('toggleNetworkBtn');
            const modeText = document.getElementById('modeStatus');
            addBtn.className = addBtn.className.replace('ring-2 ring-blue-500 bg-blue-50', '');
            editBtn.className = editBtn.className.replace('ring-2 ring-blue-500 bg-blue-50', '');

            if(isAddingPointMode) {
                addBtn.className += ' ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900';
                modeText.innerText = "Haz CLIC en el mapa para añadir"; modeText.className = "text-xs font-bold text-green-600 mt-2 text-center animate-pulse"; canvas.style.cursor='crosshair';
            } else if(isNetworkMode) {
                editBtn.className += ' ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900';
                modeText.innerText = "Arrastra los círculos para moverlos"; modeText.className = "text-xs font-bold text-blue-600 mt-2 text-center"; canvas.style.cursor='move';
            } else {
                modeText.innerText = "Modo Navegación"; modeText.className = "text-[10px] text-gray-400 mt-2 text-center"; canvas.style.cursor='grab';
            }
        }

        function addItem(type, x, y) {
            if (!backgroundImg) return showToast("Sube un plano primero", "error");
            const id = Date.now();
            let width = 30, height = 30;
            if (type === 'monitor') { width = 60; height = 35; } 
            else if (type === 'monitor-single') { width = 35; height = 30; } 
            else if (type === 'desk') { width = 80; height = 45; }
            if (!x) { x = (canvas.width / 2 / camera.zoom) - camera.x; y = (canvas.height / 2 / camera.zoom) - camera.y; }
            items.push({ id, type, x, y, width, height, ratio: height/width, rotation: 0 });
            selectedItemId = id; selectedNetworkPointId = null;
            updateUI(); syncSliderToSelection(); draw();
        }

        function duplicateSelected() {
            if (!selectedItemId) return;
            const original = items.find(i => i.id === selectedItemId);
            if (!original) return;
            const id = Date.now();
            const newItem = { ...original, id: id, x: original.x + (20 * UPSCALE_FACTOR), y: original.y + (20 * UPSCALE_FACTOR) };
            items.push(newItem);
            selectedItemId = id;
            updateUI(); syncSliderToSelection(); draw();
            showToast("Item duplicado");
        }

        function deleteSelected() { if(selectedItemId) { items = items.filter(i => i.id !== selectedItemId); selectedItemId = null; updateUI(); draw(); } }
        function deleteSelectedPoint() { if(selectedNetworkPointId && confirm("¿Borrar el puesto "+selectedNetworkPointId+"?")) { networkPoints = networkPoints.filter(p => p.id !== selectedNetworkPointId); selectedNetworkPointId = null; draw(); } }
        function handleResizeChange(e) { 
            if (!selectedItemId) return; 
            const item = items.find(i => i.id === selectedItemId); 
            if (item) { item.width = parseInt(e.target.value); item.height = item.width * item.ratio; draw(); } 
        }
        function handleRotationChange(e) {
            if (!selectedItemId) return;
            const item = items.find(i => i.id === selectedItemId);
            if (item) { item.rotation = parseInt(e.target.value); document.getElementById('rotationValueDisplay').innerText = item.rotation + "°"; draw(); }
        }

        function syncSliderToSelection() {
            const item = items.find(i => i.id === selectedItemId);
            if (item) { 
                sizeSlider.value = item.width; 
                rotationSlider.value = item.rotation || 0;
                document.getElementById('sizeValueDisplay').innerText = item.width + 'px'; 
                document.getElementById('rotationValueDisplay').innerText = (item.rotation || 0) + '°';
                
                if (item.type !== 'desk') {
                    const nearest = getNearestPoint(item);
                    const infoBox = document.getElementById('assignmentInfo');
                    if (nearest) {
                        infoBox.classList.remove('hidden');
                        document.getElementById('assignmentText').innerText = "Conectado a: " + nearest.point.id;
                    } else { infoBox.classList.add('hidden'); }
                } else { document.getElementById('assignmentInfo').classList.add('hidden'); }
            }
        }
        function changeZoom(delta) {
            if (!backgroundImg) return;
            const newZoom = Math.min(Math.max(camera.zoom + delta, 0.1), 5);
            const w = canvas.width; const h = canvas.height;
            const centerWx = (w/2 / camera.zoom) - camera.x;
            const centerWy = (h/2 / camera.zoom) - camera.y;
            camera.zoom = newZoom;
            camera.x = (w/2 / camera.zoom) - centerWx;
            camera.y = (h/2 / camera.zoom) - centerWy;
            draw();
        }
        function resetView() {
            if (!backgroundImg) return;
            camera = { x: 0, y: 0, zoom: 0.9 };
            camera.x = (canvas.width - canvas.width*0.9)/2 / 0.9;
            camera.y = (canvas.height - canvas.height*0.9)/2 / 0.9;
            draw();
        }

        function exportToExcel() {
            if (!backgroundImg) return showToast("Nada para exportar", "error");
            let report = networkPoints.map(p => ({ id: p.id, dualMonitors: 0, singleMonitors: 0, docks: 0, desks: 0, totalScreens: 0 }));
            items.forEach(item => {
                const nearest = getNearestPoint(item);
                if (nearest) {
                    const idx = networkPoints.findIndex(p => p.id === nearest.point.id);
                    if (idx !== -1) {
                        if (item.type === 'monitor') report[idx].dualMonitors++;
                        else if (item.type === 'monitor-single') report[idx].singleMonitors++;
                        else if (item.type === 'dock') report[idx].docks++;
                        else if (item.type === 'desk') report[idx].desks++;
                    }
                }
            });
            report.forEach(r => { r.totalScreens = (r.dualMonitors * 2) + r.singleMonitors; });
            const csvRows = [];
            csvRows.push(['Puesto ID', 'Escritorios', 'Kits Doble Monitor', 'Monitores Simples', 'Total Pantallas', 'Docking Stations']);
            report.forEach(r => { csvRows.push([r.id, r.desks, r.dualMonitors, r.singleMonitors, r.totalScreens, r.docks]); });
            const csvString = csvRows.map(e => e.join(",")).join("\n");
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", "inventario_oficina.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast("Excel descargado");
        }

        function exportImage() {
            if (!backgroundImg) return showToast("Nada para exportar", "error");
            const tempCam = {...camera};
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
            items.filter(i => i.type === 'desk').forEach(item => {
                 ctx.save(); ctx.translate(item.x, item.y); 
                 if (item.rotation) ctx.rotate(item.rotation * Math.PI / 180);
                 const scale = UPSCALE_FACTOR; ctx.scale(scale, scale);
                 drawDeskIcon(ctx, -item.width/2, -item.height/2, item.width, item.height); ctx.restore();
            });
            drawAssignments();
            drawNetworkPoints(0.6);
            items.filter(i => i.type !== 'desk').forEach(i => {
                 ctx.save(); ctx.translate(i.x, i.y);
                 if (i.rotation) ctx.rotate(i.rotation * Math.PI / 180);
                 const scale = UPSCALE_FACTOR; ctx.scale(scale, scale);
                 if(i.type==='monitor') drawMonitorIcon(ctx, -i.width/2, -i.height/2, i.width, i.height);
                 else if(i.type==='monitor-single') drawSingleMonitorIcon(ctx, -i.width/2, -i.height/2, i.width, i.height);
                 else if(i.type==='dock') drawDockIcon(ctx, -i.width/2, -i.height/2, i.width, i.height);
                 ctx.restore();
            });
            const link = document.createElement('a');
            link.download = 'layout_oficina.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            camera = tempCam; draw();
            showToast("Imagen descargada");
        }

        function updateUI() {
            const dual = items.filter(i => i.type === 'monitor').length;
            const single = items.filter(i => i.type === 'monitor-single').length;
            const docks = items.filter(i => i.type === 'dock').length;
            const desks = items.filter(i => i.type === 'desk').length;
            document.getElementById('count-monitor').innerText = dual;
            document.getElementById('count-monitor-single').innerText = single;
            document.getElementById('count-dock').innerText = docks;
            document.getElementById('count-desk').innerText = desks;
            const selControls = document.getElementById('selectionControls');
            if (selectedItemId) { selControls.classList.remove('opacity-50', 'pointer-events-none'); } else { selControls.classList.add('opacity-50', 'pointer-events-none'); }
        }

        function showToast(msg, type='success') {
            const t = document.getElementById('toast');
            document.getElementById('toastMsg').innerText = msg;
            t.classList.remove('opacity-0');
            setTimeout(() => t.classList.add('opacity-0'), 3000);
        }
        
        canvas.addEventListener('contextmenu', event => event.preventDefault());
    </script>
</body>
</html>
